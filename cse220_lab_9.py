# -*- coding: utf-8 -*-
"""cse220 lab 9

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mo-cpIQOnycGDVYpni4T5QQ7y9zRwFkC
"""

#task 1 ***(adjacency matrix representation)
import numpy as np
class Graph:
    def __init__(self, num_vertices):#self,5
      self.num_vertices=num_vertices
      self.adj_matrix=np.zeros((num_vertices,num_vertices),dtype=int)
    def add_edges(self, edges):
      for u,v in edges:
        self.adj_matrix[u][v]=1
        self.adj_matrix[v][u]=1
    def print_matrix(self):
        print(self.adj_matrix)
    def max_degree(self):
      maxdegree=-1
      for j in range(self.num_vertices):
        degree=0
        for i in range(self.num_vertices):
          if self.adj_matrix[j][i]==1:
            degree+=1
        if degree>maxdegree:
          maxdegree=degree
      return maxdegree
# Driver code
num_vertices = 7
edges = [
    (0, 1),
    (0, 2),
    (0, 3),
    (1, 2),
    (1, 4),
    (1, 5),
    (2, 3),
    (2, 6),
    (3, 4),
    (3, 6),
    (4, 5),
    (4, 6),
    (5, 6),
    (5, 0),
    (6, 1),
    (6, 0)
]
# Create graph instance
graph = Graph(num_vertices)
print("Before putting connections:")
graph.print_matrix()
# Add edges
graph.add_edges(edges)#3 line er sb edges jache.
print("\nAfter putting connections:")
graph.print_matrix()

print("\nMaximum degree of a vertex:", graph.max_degree())

#task1 ***(adjacency list representation)
class Edge:
    def __init__(self, source, destination, next_node=None):
        """Edge to represent a connection from source to destination."""
        self.source = source
        self.destination = destination
        self.next = next_node
class AdjacencyListGraph:
    def __init__(self, num_vertices):
        """Initialize the graph with the given number of vertices."""
        self.num_vertices = num_vertices
        self.adj_list = [None] * num_vertices  # List to hold the adjacency list for each vertex
    def add_edges(self, edges):
        """Add edges to the adjacency list for an undirected graph."""
        for source, destination in edges:
            self.add_edge(source, destination) # u to v
            self.add_edge(destination, source)  # v to u #For undirected graph
    def add_edge(self, source, destination):
        """Helper method to add an edge from source to destination."""
        ## Prepend to have insertion in O(1) time
        new_edge = Edge(source, destination)  # Create a new edge
        new_edge.next = self.adj_list[source]  # Link the new edge to the current list
        self.adj_list[source] = new_edge  # Update the adjacency list for the source vertex
    def print_list(self):
        """Print the adjacency list."""
        print("Adjacency List:")
        for i in range(self.num_vertices):
            print(f"{i}: ", end="")
            current = self.adj_list[i]
            while current:
                print(f"{current.destination}", end=" ")
                current = current.next
            print()
    def find_neighbors(self, vertex):
        """Find and print neighbors of a given vertex."""
        print(f"\nNeighbors of vertex {vertex}: ", end="")
        current = self.adj_list[vertex]
        first = True
        while current:
            if current != self.adj_list[vertex]:  # Add a comma if it's not the first element
                print(", ", end="")
            print(f"{current.destination}", end="")
            current = current.next
        print()
    def max_degree(self):
      maxdegree=-1
      for i in self.adj_list:#i=node in list
        degree=0
        temp=i
        while temp!=None:
          degree+=1
          temp=temp.next
        if degree>maxdegree:
          maxdegree=degree
      return maxdegree
# Driver code
num_vertices = 7
edges = [
    (0, 1),
    (0, 2),
    (0, 3),
    (1, 2),
    (1, 4),
    (1, 5),
    (2, 3),
    (2, 6),
    (3, 4),
    (3, 6),
    (4, 5),
    (4, 6),
    (5, 6),
    (5, 0),
    (6, 1),
    (6, 0)
]
# Create an instance of the AdjacencyListGraph class
graph = AdjacencyListGraph(num_vertices)
print("Before adding connections:")
graph.print_list()
# Add edges to the adjacency list
graph.add_edges(edges)
print("\nAfter adding connections:")
graph.print_list()
# Find neighbors for each vertex
for vertex in range(num_vertices):
    graph.find_neighbors(vertex)
print("\nMaximum degree of a vertex:", graph.max_degree())

#task2 ***(adjacency matrix representation)
import numpy as np
class Undirected_Weighted_AdjacencyMatrix:
    def __init__(self, num_vertices):
        self.num_vertices=num_vertices
        self.adj_matrix=np.zeros((num_vertices, num_vertices), dtype=int)
    def add_edges(self,edges):
        for u, v, weight in edges:
            self.adj_matrix[u][v]=weight
            self.adj_matrix[v][u]=weight
    def print_matrix(self):
        print("Adjacency Matrix:")
        for row in self.adj_matrix:
            print(row)
    def max_weight(self):
        maxweight=-1
        for i in range(self.num_vertices):
            sum_weight = 0
            for j in range(self.num_vertices):
              if self.adj_matrix[i][j]!=0:#jdi i(u),j(v) er mddhe edge thake dn weight thakbe. nd sei weight=1(jdi weight dea na thake edge e) or onno num ber(weight dea thakle setai hbe weght)
                sum_weight += self.adj_matrix[i][j]#adj_matrix[i][j]=weight... oi i,j vertex er edge er weight
            if sum_weight>maxweight:
                maxweight=sum_weight
        return maxweight
# Driver code
num_vertices = 7
edges = [
    (0, 1, 4),
    (0, 2, 3),
    (0, 3, 2),
    (1, 2, 5),
    (1, 4, 7),
    (1, 5, 6),
    (2, 3, 4),
    (2, 6, 8),
    (3, 4, 2),
    (3, 6, 5),
    (4, 5, 1),
    (4, 6, 6),
    (5, 6, 3),
    (5, 0, 2),
    (6, 1, 4),
    (6, 0, 7)
]
graph = Undirected_Weighted_AdjacencyMatrix(num_vertices)
print("Before putting connections:")
graph.print_matrix()
graph.add_edges(edges)
print("After putting connections:")
graph.print_matrix()

print("Max weight of a vertex:", graph.max_weight())

#task2 ***(adjacency list representation)
class WEdge:
    def __init__(self, source, destination, weight, next_node=None):
        self.source = source
        self.destination = destination
        self.weight = weight
        self.next = next_node
class Undirected_Weighted_AdjacencyList:
    def __init__(self, num_vertices):
        self.num_vertices = num_vertices
        self.adj_list = [None] * num_vertices  # Initialize the adjacency list for each vertex
    def add_edges(self, edges):
        """Add edges with weights to the adjacency list for an undirected graph."""
        for source, destination, weight in edges:
            self.add_edge(source, destination, weight)
            self.add_edge(destination, source, weight)  # Add the reverse direction for undirected
    def add_edge(self, source, destination, weight):
        """Helper method to add an edge from source to destination with the given weight."""
        ## Prepend to have insertion in O(1) time
        new_edge = WEdge(source, destination, weight)
        new_edge.next = self.adj_list[source]
        self.adj_list[source] = new_edge
    def print_list(self):
        """Print the adjacency list with weights."""
        print("Adjacency List with Weights:")
        for i in range(self.num_vertices):
            print(f"{i}: ", end="")
            current = self.adj_list[i]
            while current:
                print(f"(s={current.source}, d={current.destination}, w={current.weight})", end="")
                if current.next:
                    print(", ", end="")
                current = current.next
            print()
    def find_neighbors(self, vertex):
        """Find and print neighbors of a given vertex with weights."""
        print(f"\nNeighbors of vertex {vertex}: ", end="")
        current = self.adj_list[vertex]
        while current:
            print(f"({current.destination}, {current.weight})", end="")
            if current.next:
                print(", ", end="")
            current = current.next
        print()
    def max_weight(self):
        maxweight=-1
        for i in self.adj_list:
            sum_weight=0
            temp=i
            while temp!=None:
              sum_weight+=temp.weight
              temp=temp.next
            if sum_weight>maxweight:
              maxweight=sum_weight
        return maxweight
# Driver code
num_vertices = 7
edges = [
    (0, 1, 4),
    (0, 2, 3),
    (0, 3, 2),
    (1, 2, 5),
    (1, 4, 7),
    (1, 5, 6),
    (2, 3, 4),
    (2, 6, 8),
    (3, 4, 2),
    (3, 6, 5),
    (4, 5, 1),
    (4, 6, 6),
    (5, 6, 3),
    (5, 0, 2),
    (6, 1, 4),
    (6, 0, 7)
]
graph = Undirected_Weighted_AdjacencyList(num_vertices)
print("Before adding connections:")
graph.print_list()
graph.add_edges(edges)
print('-'*50)
print("\nAfter adding connections:")
graph.print_list()
print('-'*50)
for vertex in range(num_vertices):
    graph.find_neighbors(vertex)
print('-'*50)
print("Max weight of a vertex:", graph.max_weight())

#task3 for task1***(adjacency matrix representation)
import numpy as np
class Undirected_Weighted_AdjacencyMatrix:
    def __init__(self, num_vertices):
        self.num_vertices=num_vertices
        self.adj_matrix=np.zeros((num_vertices, num_vertices), dtype=int)
    def add_edges(self,edges):
        for u, v, weight in edges:
            self.adj_matrix[u][v]=weight
    def print_matrix(self):
        print("Adjacency Matrix:")
        for row in self.adj_matrix:
            print(row)
    def max_degree(self):
      maxdegree=-1
      for j in range(self.num_vertices):
        degree=0
        for i in range(self.num_vertices):
          if self.adj_matrix[j][i]!=0:
            degree+=1
        if degree>maxdegree:
          maxdegree=degree
      return maxdegree
# Driver code
num_vertices = 7
edges = [
    (0, 1, 4),
    (0, 2, 3),
    (0, 3, 2),
    (1, 2, 5),
    (1, 4, 7),
    (1, 5, 6),
    (2, 3, 4),
    (2, 6, 8),
    (3, 4, 2),
    (3, 6, 5),
    (4, 5, 1),
    (4, 6, 6),
    (5, 6, 3),
    (5, 0, 2),
    (6, 1, 4),
    (6, 0, 7)
]
graph = Undirected_Weighted_AdjacencyMatrix(num_vertices)
print("Before putting connections:")
graph.print_matrix()
graph.add_edges(edges)
print("After putting connections:")
graph.print_matrix()
print("Maximum degree of a vertex:", graph.max_degree())

#task3 for task1 ***(adjacency list representation)
class WEdge:
    def __init__(self, source, destination, weight, next_node=None):
        self.source = source
        self.destination = destination
        self.weight = weight
        self.next = next_node

class Directed_Weighted_AdjacencyList:
    def __init__(self, num_vertices):
        self.num_vertices = num_vertices
        self.adj_list = [None] * num_vertices  # Initialize the adjacency list for each vertex

    def add_edges(self, edges):
        """Add directed edges with weights to the adjacency list."""
        for source, destination, weight in edges:
            self.add_edge(source, destination, weight)

    def add_edge(self, source, destination, weight):
        """Helper method to add a directed edge from source to destination with the given weight."""
        new_edge = WEdge(source, destination, weight)
        new_edge.next = self.adj_list[source]
        self.adj_list[source] = new_edge

    def print_list(self):
        """Print the adjacency list with weights."""
        print("Adjacency List with Weights:")
        for i in range(self.num_vertices):
            print(f"{i}: ", end="")
            current = self.adj_list[i]
            while current:
                print(f"(s={current.source}, d={current.destination}, w={current.weight})", end="")
                if current.next:
                    print(", ", end="")
                current = current.next
            print()

    def find_neighbors(self, vertex):
        """Find and print neighbors of a given vertex with weights."""
        print(f"\nNeighbors of vertex {vertex}: ", end="")
        current = self.adj_list[vertex]
        while current:
            print(f"({current.destination}, {current.weight})", end="")
            if current.next:
                print(", ", end="")
            current = current.next
        print()

    def max_degree(self):
        """Find the maximum out-degree (number of outgoing edges) among all vertices."""
        maxdegree = -1
        for i in self.adj_list:
            len_ll = 0
            temp = i
            while temp is not None:
                len_ll += 1
                temp = temp.next
            if len_ll > maxdegree:
                maxdegree = len_ll
        return maxdegree


# Driver code
num_vertices = 7
edges = [
    (0, 1, 4),
    (0, 2, 3),
    (0, 3, 2),
    (1, 2, 5),
    (1, 4, 7),
    (1, 5, 6),
    (2, 3, 4),
    (2, 6, 8),
    (3, 4, 2),
    (3, 6, 5),
    (4, 5, 1),
    (4, 6, 6),
    (5, 6, 3),
    (5, 0, 2),
    (6, 1, 4),
    (6, 0, 7)
]

graph = Directed_Weighted_AdjacencyList(num_vertices)

print("Before adding connections:")
graph.print_list()

graph.add_edges(edges)

print('-' * 50)
print("\nAfter adding connections:")
graph.print_list()

print('-' * 50)
for vertex in range(num_vertices):
    graph.find_neighbors(vertex)

print('-' * 50)
print("\nMaximum out-degree of a vertex:", graph.max_degree())

#task3 for task2 ***(adjacency matrix representation)
import numpy as np
class Undirected_Weighted_AdjacencyMatrix:
    def __init__(self, num_vertices):
        self.num_vertices=num_vertices
        self.adj_matrix=np.zeros((num_vertices, num_vertices), dtype=int)
    def add_edges(self,edges):
        for u, v, weight in edges:
            self.adj_matrix[u][v]=weight
    def print_matrix(self):
        print("Adjacency Matrix:")
        for row in self.adj_matrix:
            print(row)
    def max_weight(self):
        maxweight=-1
        for i in range(self.num_vertices):
            sum_weight = 0
            for j in range(self.num_vertices):
              if self.adj_matrix[i][j]!=0:
                sum_weight += self.adj_matrix[i][j]
            if sum_weight>maxweight:
                maxweight=sum_weight
        return maxweight
# Driver code
num_vertices = 7
edges = [
    (0, 1, 4),
    (0, 2, 3),
    (0, 3, 2),
    (1, 2, 5),
    (1, 4, 7),
    (1, 5, 6),
    (2, 3, 4),
    (2, 6, 8),
    (3, 4, 2),
    (3, 6, 5),
    (4, 5, 1),
    (4, 6, 6),
    (5, 6, 3),
    (5, 0, 2),
    (6, 1, 4),
    (6, 0, 7)
]
graph = Undirected_Weighted_AdjacencyMatrix(num_vertices)
print("Before putting connections:")
graph.print_matrix()
graph.add_edges(edges)
print("After putting connections:")
graph.print_matrix()

print("Max weight of a vertex:", graph.max_weight())

#task3 for task2 ***(adjacency list representation)
class WEdge:
    def __init__(self, source, destination, weight, next_node=None):
        self.source = source
        self.destination = destination
        self.weight = weight
        self.next = next_node

class Directed_Weighted_AdjacencyList:
    def __init__(self, num_vertices):
        self.num_vertices = num_vertices
        self.adj_list = [None] * num_vertices  # Initialize the adjacency list for each vertex

    def add_edges(self, edges):
        """Add directed edges with weights to the adjacency list."""
        for source, destination, weight in edges:
            self.add_edge(source, destination, weight)

    def add_edge(self, source, destination, weight):
        """Helper method to add a directed edge from source to destination with the given weight."""
        new_edge = WEdge(source, destination, weight)
        new_edge.next = self.adj_list[source]
        self.adj_list[source] = new_edge

    def print_list(self):
        """Print the adjacency list with weights."""
        print("Adjacency List with Weights:")
        for i in range(self.num_vertices):
            print(f"{i}: ", end="")
            current = self.adj_list[i]
            while current:
                print(f"(s={current.source}, d={current.destination}, w={current.weight})", end="")
                if current.next:
                    print(", ", end="")
                current = current.next
            print()

    def find_neighbors(self, vertex):
        """Find and print neighbors of a given vertex with weights."""
        print(f"\nNeighbors of vertex {vertex}: ", end="")
        current = self.adj_list[vertex]
        while current:
            print(f"({current.destination}, {current.weight})", end="")
            if current.next:
                print(", ", end="")
            current = current.next
        print()
    def max_weight(self):
        maxweight=-1
        for i in self.adj_list:
            sum_weight=0
            temp=i
            while temp!=None:
              sum_weight+=temp.weight
              temp=temp.next
            if sum_weight>maxweight:
              maxweight=sum_weight
        return maxweight
# Driver code
num_vertices = 7
edges = [
    (0, 1, 4),
    (0, 2, 3),
    (0, 3, 2),
    (1, 2, 5),
    (1, 4, 7),
    (1, 5, 6),
    (2, 3, 4),
    (2, 6, 8),
    (3, 4, 2),
    (3, 6, 5),
    (4, 5, 1),
    (4, 6, 6),
    (5, 6, 3),
    (5, 0, 2),
    (6, 1, 4),
    (6, 0, 7)
]

graph = Directed_Weighted_AdjacencyList(num_vertices)

print("Before adding connections:")
graph.print_list()

graph.add_edges(edges)

print('-' * 50)
print("\nAfter adding connections:")
graph.print_list()

print('-' * 50)
for vertex in range(num_vertices):
    graph.find_neighbors(vertex)

print('-' * 50)
print("Max weight of a vertex:", graph.max_weight())

#task4 ***(adjacency matrix representation)
import numpy as np
class Undirected_Weighted_AdjacencyMatrix:
    def __init__(self, num_vertices):
        self.num_vertices=num_vertices
        self.adj_matrix=np.zeros((num_vertices, num_vertices), dtype=int)
    def add_edges(self,edges):
        for u, v, weight in edges:
            self.adj_matrix[u][v]=weight
    def print_matrix(self):
        print("Adjacency Matrix:")
        for row in self.adj_matrix:
            print(row)
    def convert_undirect_matrix(self):
        for i in range(self.num_vertices):
          for j in range(self.num_vertices):
            if self.adj_matrix[i][j]!=0:
              self.adj_matrix[j][i]=self.adj_matrix[i][j]
        return self.adj_matrix
# Driver code
num_vertices = 7
edges = [
    (0, 1, 4),
    (0, 2, 3),
    (0, 3, 2),
    (1, 2, 5),
    (1, 4, 7),
    (1, 5, 6),
    (2, 3, 4),
    (2, 6, 8),
    (3, 4, 2),
    (3, 6, 5),
    (4, 5, 1),
    (4, 6, 6),
    (5, 6, 3),
    (5, 0, 2),
    (6, 1, 4),
    (6, 0, 7)
]
graph = Undirected_Weighted_AdjacencyMatrix(num_vertices)
print("Before putting connections:")
graph.print_matrix()
graph.add_edges(edges)
print("After putting connections:")
graph.print_matrix()
print(graph.convert_undirect_matrix())

#task4 **(adjacency list representation)
class WEdge:
    def __init__(self, source, destination, weight, next_node=None):
        self.source = source
        self.destination = destination
        self.weight = weight
        self.next = next_node

class Directed_Weighted_AdjacencyList:
    def __init__(self, num_vertices):
        self.num_vertices = num_vertices
        self.adj_list = [None] * num_vertices

    def add_edges(self, edges):
        for source, destination, weight in edges:
            self.add_edge(source, destination, weight)

    def add_edge(self, source, destination, weight):
        new_edge = WEdge(source, destination, weight)
        new_edge.next = self.adj_list[source]
        self.adj_list[source] = new_edge

    def print_list(self):
        print("indirect Adjacency List with Weights:")
        for i in range(self.num_vertices):
            print(f"{i}: ", end="")
            current = self.adj_list[i]
            while current:
                print(f"({current.destination},{current.weight})", end="")
                if current.next:
                    print(", ", end="")
                current = current.next
            print()
    def edge_exists(self, u, v):
      current = self.adj_list[u]
      while current!=None:
          if current.destination == v:
              return True
          current = current.next
      return False
    def covert_undirect_list(self):
      for i in range(len(self.adj_list)):
        temp = self.adj_list[i]#temp=0,1,4
        while temp!=None:
            src = temp.source#src=1
            dst = temp.destination#src=1
            weight = temp.weight#src=4
            if not self.edge_exists(dst, src):
                self.add_edge(dst, src, weight)
            temp = temp.next
      return

# Driver code
num_vertices = 7
edges = [
    (0, 1, 4), (0, 2, 3), (0, 3, 2), (1, 2, 5), (1, 4, 7), (1, 5, 6),
    (2, 3, 4), (2, 6, 8), (3, 4, 2), (3, 6, 5), (4, 5, 1), (4, 6, 6),
    (5, 6, 3), (5, 0, 2), (6, 1, 4), (6, 0, 7)
]
graph = Directed_Weighted_AdjacencyList(num_vertices)
print("Before adding connections:")
graph.print_list()
graph.add_edges(edges)
print('-' * 50)
print("After adding directed connections:")
graph.print_list()
print('-' * 50)
print("After converting to undirected list:")
graph.covert_undirect_list()
graph.print_list()