# -*- coding: utf-8 -*-
"""cse220 lab9 graph

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GeBZDXadpcm_uyn4YZOgg2X0Zo_7CR3g
"""

#adjacent matrix representation... khatay graph ase
import numpy as np
graph = np.zeros((6, 6), dtype=int)#matrix creat holo. total 6 ta node silo(0,1,2,3,4,5) ti 6*6 er matrix creat krsi.
#j koyta node toto size er matrix creat krte hbe alws
print(graph)#matrix print kre dkhtesi creat hoise kina thikthak
graph[0][5] = 15#0 node er sthe jar jar connection(0 er sthe 5 er connection graph e sudhu)take evabe connect krte hbe. nd 15 holo 0,5 node er mdher weight
graph[1][2], graph[1][5] = 44, 8#1,2 er sthe connection creat krlam jar wieght 44, and 1 er stge 5 er connection create krlam jar weight 8
graph[2][1], graph[2][3], graph[2][4] = 44, 9, 10
graph[3][2], graph[3][4], graph[3][5] = 9, 7, 15
graph[4][2], graph[4][3] = 10, 7
graph[5][0], graph[5][1], graph[5][3] = 15, 8, 15
print(graph)#connection and weight soho matrix print.[0 0 0 0 0 15]ekhane 15 holo 0,5 er connection er wweight ti seta 5 idx e bosche.
#[ 0  0 44  0  0  8]... idx 1,2 er connection e weight 44 ti idx=2 te 44 bosche

# Adjacency list representation
import numpy as np
class Edge:
    def __init__(self, u, v, w):#edge creat. u=1st node, v=2nd node jar sthe 1st ta connnected thakbe.. node duitar mdher weight=w
        self.u = u#source vertex
        self.v = v#destination vertex(end jekhane hbe edge ta)
        self.w = w#weight of th edge
class Node:
    def __init__(self, edge, next=None):#edge=Edge(0, 5, 15).. ekhane edge holo obj ja Edge cls er under e create hoise
        self.edge = edge#Edge(0, 5, 15).. edge holo obj Edge cls er under e create hoise
        self.next = next
graph2 = np.array([None] * 6, dtype=object)#6 ta node er jnno array create krtesi 6 length er. Each index will point to the head of a linked list representing the adjacency list of that vertex.
#Node 0
a0 = Node(Edge(0, 5, 15))#edge class e jeye first e edge create krbe. vertex 0 has 1 edge: to vertex 5 with weight 15.. then node create hbe
graph2[0] = a0#graph/array er idx=0 te link list er head(a0) bosbe
#Node 1
a1 = Node(Edge(1, 2, 44))#Vertex 1 has two edges: to 2 with weight 44 and to 5 with weight 8
b1 = Node(Edge(1, 5, 8))
a1.next = b1#a1 -> b1 linklist created
graph2[1] = a1#graph ba array er idx=1 e a1 -> b1 ei link ist er head=a1 boslo
#Node 2. graph2 er idx=2 te bosbe ei link list(a2 -> b2 -> c2)
a2 = Node(Edge(2, 1, 44))
b2 = Node(Edge(2, 3, 9))
c2 = Node(Edge(2, 4, 10))
a2.next = b2
b2.next = c2#a2 -> b2 -> c2.. ekhane a2,b2,c2 er elem=edge(edge holo obj)
graph2[2] = a2
#Node 3
a3 = Node(Edge(3, 2, 9))
b3 = Node(Edge(3, 4, 7))
c3 = Node(Edge(3, 5, 15))
a3.next = b3
b3.next = c3
graph2[3] = a3
# Node 4
a4 = Node(Edge(4, 2, 10))
b4 = Node(Edge(4, 3, 7))
a4.next = b4
graph2[4] = a4
# Node 5
a5 = Node(Edge(5, 0, 15))
b5 = Node(Edge(5, 1, 8))
c5 = Node(Edge(5, 3, 15))
a5.next = b5
b5.next = c5
graph2[5] = a5
# Function to print the adjacency list
def print_graph(graph):#graph=graph2
    for i in range(len(graph)):#graph holo array. jar len=6.. i(idx)=0,1,2,3,4,5
        #print(graph[i])### output=address of head node
        print(f"Node {i}:", end=" ")
        temp = graph[i]#temp=head node(jeta address) of the linklist..
        while temp!=None:
            e = temp.edge#edge=obj created under Edge class...temp.elem=temp.edge... e=address of edge. cz temp.edgeadress
            print(f"-->({e.v}, {e.w})", end="")#-->(2, 44) at idx=1.. i=0 tokhon e.v=5,e.w=15
            temp = temp.next
        print()
# Print the graph
print_graph(graph2)#Node 1: (2, 44) -->(5, 8).. idx=1 e (2,44) (5,8) er sthe link list hisebe add hoise

#Adjacency list for Undirected unWeighted graph
class Edge:
    def __init__(self, source, destination, next_node=None):
        """Edge to represent a connection from source to destination."""
        self.source = source
        self.destination = destination
        self.next = next_node
###############################################################################
class AdjacencyListGraph:
    def __init__(self, num_vertices):
        """Initialize the graph with the given number of vertices."""
        self.num_vertices = num_vertices
        self.adj_list = [None] * num_vertices  # List to hold the adjacency list for each vertex
    def add_edges(self, edges):
        """Add edges to the adjacency list for an undirected graph."""
        for source, destination in edges:
            self.add_edge(source, destination) # u to v
            self.add_edge(destination, source)  # v to u #For undirected graph
    def add_edge(self, source, destination):
        """Helper method to add an edge from source to destination."""
        ## Prepend to have insertion in O(1) time
        new_edge = Edge(source, destination)  # Create a new edge
        new_edge.next = self.adj_list[source]  # Link the new edge to the current list
        self.adj_list[source] = new_edge  # Update the adjacency list for the source vertex
    def print_list(self):
        """Print the adjacency list."""
        print("Adjacency List:")
        for i in range(self.num_vertices):
            print(f"{i}: ", end="")
            current = self.adj_list[i]
            while current:
                print(f"{current.destination}", end=" ")
                current = current.next
            print()
    def find_neighbors(self, vertex):
        """Find and print neighbors of a given vertex."""
        print(f"\nNeighbors of vertex {vertex}: ", end="")
        current = self.adj_list[vertex]
        first = True
        while current:
            if current != self.adj_list[vertex]:  # Add a comma if it's not the first element
                print(", ", end="")
            print(f"{current.destination}", end="")
            current = current.next
        print()
# Driver code
num_vertices = 5
edges = [
    (0, 1),  # u, v
    (0, 3),
    (1, 3),
    (1, 2),
    (1, 4),
    (2, 4),
    (3, 4)
]
# Create an instance of the AdjacencyListGraph class
graph = AdjacencyListGraph(num_vertices)
print("Before adding connections:")
graph.print_list()
# Add edges to the adjacency list
graph.add_edges(edges)
print("\nAfter adding connections:")
graph.print_list()
# Find neighbors for each vertex
for vertex in range(num_vertices):
    graph.find_neighbors(vertex)

#task1
# Adjacency list representation
import numpy as np
class Edge:
    def __init__(self, u, v, w):  # edge create
        self.u = u
        self.v = v
        self.w = w
class Node:
    def __init__(self, edge, next=None):
        self.edge = edge
        self.next = next
graph2 = np.array([None] * 7, dtype=object)  # 7 vertices (0 to 6)
# Add edges manually (weighted, directed format as in your structure)
# Node 0
a0 = Node(Edge(0, 1, 10))
b0 = Node(Edge(0, 2, 5))
a0.next = b0
graph2[0] = a0
# Node 1
a1 = Node(Edge(1, 0, 10))
b1 = Node(Edge(1, 3, 7))
a1.next = b1
graph2[1] = a1
# Node 2
a2 = Node(Edge(2, 0, 5))
b2 = Node(Edge(2, 3, 8))
c2 = Node(Edge(2, 4, 12))
a2.next = b2
b2.next = c2
graph2[2] = a2
# Node 3
a3 = Node(Edge(3, 1, 7))
b3 = Node(Edge(3, 2, 8))
c3 = Node(Edge(3, 5, 4))
a3.next = b3
b3.next = c3
graph2[3] = a3
# Node 4
a4 = Node(Edge(4, 2, 12))
b4 = Node(Edge(4, 6, 6))
a4.next = b4
graph2[4] = a4
# Node 5
a5 = Node(Edge(5, 3, 4))
b5 = Node(Edge(5, 6, 3))
a5.next = b5
graph2[5] = a5
# Node 6
a6 = Node(Edge(6, 4, 6))
b6 = Node(Edge(6, 5, 3))
c6 = Node(Edge(6, 1, 9))
a6.next = b6
b6.next = c6
graph2[6] = a6
# Function to print the adjacency list
def print_graph(graph):
    for i in range(len(graph)):
        print(f"Node {i}:", end=" ")
        temp = graph[i]
        while temp != None:
            e = temp.edge
            print(f"-->({e.v}, {e.w})", end="")
            temp = temp.next
        print()
# Task 1: Find vertex with maximum degree
def max_degree_vertex(graph):
    max_deg=-1
    vertex = -1
    for i in range(len(graph)):
        count=0
        temp = graph[i]
        while temp != None:
            count += 1
            temp = temp.next
        if count > max_deg:
            max_deg = count
            vertex = i
    print(f"\nVertex with maximum degree: {vertex}, Degree: {max_deg}")
# Run everything #
print_graph(graph2)
max_degree_vertex(graph2)

#task 1 ***(adjacency matrix representation)
import numpy as np
class Graph:
    def __init__(self, num_vertices):
        self.num_vertices = num_vertices
        self.adj_matrix = np.zeros((num_vertices, num_vertices), dtype=int)
    def add_edges(self, edges):
        for u, v in edges:
            self.adj_matrix[u][v] = 1
            self.adj_matrix[v][u] = 1  # Undirected graph
    def max_degree(self):
        maxdegree = 0
        for j in range(self.num_vertices):
            degree = np.sum(self.adj_matrix[j])
            if degree > maxdegree:
                maxdegree = degree
        return maxdegree
# Driver code
num_vertices = 7
edges = [
    (0, 1), (0, 2), (0, 3), (1, 2), (1, 4), (1, 5),
    (2, 3), (2, 6), (3, 4), (3, 6), (4, 5), (4, 6),
    (5, 6), (5, 0), (6, 1), (6, 0)
]
graph = Graph(num_vertices)
graph.add_edges(edges)
print(graph.max_degree())



#task1 ***(adjacency list representation)
class Edge:
    def __init__(self, source, destination, next_node=None):
        self.source = source
        self.destination = destination
        self.next = next_node
class AdjacencyListGraph:
    def __init__(self, num_vertices):
        self.num_vertices = num_vertices
        self.adj_list = [None] * num_vertices
    def add_edges(self, edges):
        for source, destination in edges:
            self.add_edge(source, destination)
            self.add_edge(destination, source)  # For undirected graph
    def add_edge(self, source, destination):
        new_edge = Edge(source, destination)
        new_edge.next = self.adj_list[source]
        self.adj_list[source] = new_edge
    def max_degree(self):
        maxdegree = 0
        for i in self.adj_list:
            degree = 0
            temp = i
            while temp:
                degree += 1
                temp = temp.next
            if degree > maxdegree:
                maxdegree = degree
        return maxdegree
# Driver code
num_vertices = 7
edges = [
    (0, 1), (0, 2), (0, 3), (1, 2), (1, 4), (1, 5),
    (2, 3), (2, 6), (3, 4), (3, 6), (4, 5), (4, 6),
    (5, 6), (5, 0), (6, 1), (6, 0)
]
graph = AdjacencyListGraph(num_vertices)
graph.add_edges(edges)
print(graph.max_degree())

#task2 ***(adjacency matrix representation)
import numpy as np
class wEdge:
    def __init__(self, num_vertices):
        self.num_vertices = num_vertices
        self.adj_matrix = np.zeros((num_vertices, num_vertices), dtype=int)
    def add_edges(self, edges):
        for u, v, weight in edges:
            self.adj_matrix[u][v] = weight
            self.adj_matrix[v][u] = weight
    def max_weight(self):
        maxweight = -1
        for i in range(self.num_vertices):
            sum_weight = 0
            for j in range(self.num_vertices):
                if self.adj_matrix[i][j] != 0:
                    sum_weight += self.adj_matrix[i][j]
            if sum_weight > maxweight:
                maxweight = sum_weight
        return maxweight
# Driver code
num_vertices = 7
edges = [
    (0, 1, 4), (0, 2, 3), (0, 3, 2), (1, 2, 5), (1, 4, 7), (1, 5, 6),
    (2, 3, 4), (2, 6, 8), (3, 4, 2), (3, 6, 5), (4, 5, 1), (4, 6, 6),
    (5, 6, 3), (5, 0, 2), (6, 1, 4), (6, 0, 7)
]
graph = wEdge(num_vertices)
graph.add_edges(edges)
print(graph.max_weight())

#task2 ***(adjacency list representation)
class Node:
    def __init__(self,u,v,w,next_node=None):
      self.u=u
      self.v=v
      self.w=w
      self.next_node=next_node
class Graph:
  def __init__(self,num_vertices):
    self.num_vertices=num_vertices
    self.adj_list=[None]*self.num_vertices
  def add_edges(self,edges):
    for u,v,w in edges:
      self.add_edge(u,v,w)
      self.add_edge(v,u,w)
  def add_edge(self,u,v,w):
    newnode=Node(u,v,w)
    newnode.next=self.adj_list[u]
    self.adj_list[u]=newnode
  def max_weight(self):
    maxw=0
    for i in self.adj_list:
      temp=i
      c=0
      while temp!=None:
        c+=temp.w
        temp=temp.next
      if c>maxw:
        maxw=c
    return maxw
# Driver code
num_vertices=7
edges=[(0, 1, 4), (0, 2, 3), (0, 3, 2), (1, 2, 5), (1, 4, 7), (1, 5, 6),
    (2, 3, 4), (2, 6, 8), (3, 4, 2), (3, 6, 5), (4, 5, 1), (4, 6, 6),
    (5, 6, 3), (5, 0, 2), (6, 1, 4), (6, 0, 7)]
graph=Graph(num_vertices)
graph.add_edges(edges)
print(graph.max_weight())

#task3 for task1***(adjacency matrix representation)
import numpy as np
class dwEdge:
    def __init__(self, num_vertices):
        self.num_vertices = num_vertices
        self.adj_matrix = np.zeros((num_vertices, num_vertices), dtype=int)
    def add_edges(self, edges):
        for u, v, weight in edges:
            self.adj_matrix[u][v] = weight
    def max_degree(self):
        maxdegree = -1
        for j in range(self.num_vertices):
            degree = 0
            for i in range(self.num_vertices):
                if self.adj_matrix[j][i] != 0:
                    degree += 1
            if degree > maxdegree:
                maxdegree = degree
        return maxdegree
# Driver code
num_vertices = 7
edges = [
    (0, 1, 4), (0, 2, 3), (0, 3, 2), (1, 2, 5), (1, 4, 7), (1, 5, 6),
    (2, 3, 4), (2, 6, 8), (3, 4, 2), (3, 6, 5), (4, 5, 1), (4, 6, 6),
    (5, 6, 3), (5, 0, 2), (6, 1, 4), (6, 0, 7)
]
graph = dwEdge(num_vertices)
graph.add_edges(edges)
print(graph.max_degree())

#task3 for task1 ***(adjacency list representation)
class WEdge:
    def __init__(self, source, destination, weight, next_node=None):
        self.source = source
        self.destination = destination
        self.weight = weight
        self.next = next_node
class dwEdge:
    def __init__(self, num_vertices):
        self.num_vertices = num_vertices
        self.adj_list = [None] * num_vertices
    def add_edges(self, edges):
        for source, destination, weight in edges:
            self.add_edge(source, destination, weight)
    def add_edge(self, source, destination, weight):
        new_edge = WEdge(source, destination, weight)
        new_edge.next = self.adj_list[source]
        self.adj_list[source] = new_edge
    def max_degree(self):
        maxdegree = -1
        for i in self.adj_list:
            count = 0
            temp = i
            while temp:
                count += 1
                temp = temp.next
            if count > maxdegree:
                maxdegree = count
        return maxdegree
# Driver code
num_vertices = 7
edges = [
    (0, 1, 4), (0, 2, 3), (0, 3, 2), (1, 2, 5), (1, 4, 7), (1, 5, 6),
    (2, 3, 4), (2, 6, 8), (3, 4, 2), (3, 6, 5), (4, 5, 1), (4, 6, 6),
    (5, 6, 3), (5, 0, 2), (6, 1, 4), (6, 0, 7)
]
graph = dwEdge(num_vertices)
graph.add_edges(edges)
print(graph.max_degree())

#task3 for task2 ***(adjacency matrix representation)
import numpy as np


class dwEdge:
    def __init__(self, num_vertices):
        self.num_vertices = num_vertices
        self.adj_matrix = np.zeros((num_vertices, num_vertices), dtype=int)


    def add_edges(self, edges):
        for u, v, weight in edges:
            self.adj_matrix[u][v] = weight


    def max_weight(self):
        maxweight = -1
        for i in range(self.num_vertices):
            sum_weight = 0
            for j in range(self.num_vertices):
                if self.adj_matrix[i][j] != 0:
                    sum_weight += self.adj_matrix[i][j]
            if sum_weight > maxweight:
                maxweight = sum_weight
        return maxweight


# Driver code
num_vertices = 7
edges = [
    (0, 1, 4),
    (0, 2, 3),
    (0, 3, 2),
    (1, 2, 5),
    (1, 4, 7),
    (1, 5, 6),
    (2, 3, 4),
    (2, 6, 8),
    (3, 4, 2),
    (3, 6, 5),
    (4, 5, 1),
    (4, 6, 6),
    (5, 6, 3),
    (5, 0, 2),
    (6, 1, 4),
    (6, 0, 7)
]
graph = dwEdge(num_vertices)
graph.add_edges(edges)


num_vertices = 7
edges = [
    (0, 1, 4), (0, 2, 3), (0, 3, 2), (1, 2, 5), (1, 4, 7), (1, 5, 6),
    (2, 3, 4), (2, 6, 8), (3, 4, 2), (3, 6, 5), (4, 5, 1), (4, 6, 6),
    (5, 6, 3), (5, 0, 2), (6, 1, 4), (6, 0, 7)
]
graph = dwEdge(num_vertices)
graph.add_edges(edges)
print(graph.max_weight())

#task3 for task2 ***(adjacency list representation)
class Node:
    def __init__(self,u,v,w,next_node=None):
      self.u=u
      self.v=v
      self.w=w
      self.next_node=next_node
class Graph:
  def __init__(self,num_vertices):
    self.num_vertices=num_vertices
    self.adj_list=[None]*self.num_vertices
  def add_edges(self,edges):
    for u,v,w in edges:
      self.add_edge(u,v,w)
  def add_edge(self,u,v,w):
    newnode=Node(u,v,w)
    newnode.next=self.adj_list[u]
    self.adj_list[u]=newnode
  def max_weight(self):
    maxw=0
    for i in self.adj_list:
      temp=i
      c=0
      while temp!=None:
        c+=temp.w
        temp=temp.next
      if c>maxw:
        maxw=c
    return maxw
# Driver code
num_vertices=7
edges=[(0, 1, 4), (0, 2, 3), (0, 3, 2), (1, 2, 5), (1, 4, 7), (1, 5, 6),
    (2, 3, 4), (2, 6, 8), (3, 4, 2), (3, 6, 5), (4, 5, 1), (4, 6, 6),
    (5, 6, 3), (5, 0, 2), (6, 1, 4), (6, 0, 7)]
graph=Graph(num_vertices)
graph.add_edges(edges)
print(graph.max_weight())

#task4 ***(adjacency matrix representation)
import numpy as np
class directed_Weighted_AdjacencyMatrix:
    def __init__(self, num_vertices):
        self.num_vertices=num_vertices
        self.adj_matrix=np.zeros((num_vertices, num_vertices), dtype=int)
    def add_edges(self,edges):
        for u, v, weight in edges:
            self.adj_matrix[u][v]=weight
    def convert_undirect_matrix(self):
        for i in range(self.num_vertices):
          for j in range(self.num_vertices):
            if self.adj_matrix[i][j]!=0:
              self.adj_matrix[j][i]=self.adj_matrix[i][j]
        return self.adj_matrix
# Driver code
num_vertices = 7
edges = [
    (0, 1, 4),
    (0, 2, 3),
    (0, 3, 2),
    (1, 2, 5),
    (1, 4, 7),
    (1, 5, 6),
    (2, 3, 4),
    (2, 6, 8),
    (3, 4, 2),
    (3, 6, 5),
    (4, 5, 1),
    (4, 6, 6),
    (5, 6, 3),
    (5, 0, 2),
    (6, 1, 4),
    (6, 0, 7)
]
graph = directed_Weighted_AdjacencyMatrix(num_vertices)
graph.add_edges(edges)
print(graph.convert_undirect_matrix())

#task4 **(adjacency list representation)
class Node:
    def __init__(self,u,v,w,next_node=None):
      self.u=u
      self.v=v
      self.w=w
      self.next_node=next_node
class Graph:
  def __init__(self,num_vertices):
    self.num_vertices=num_vertices
    self.adj_list=[None]*self.num_vertices
  def add_edges(self,edges):
    for u,v,w in edges:
      self.add_edge(u,v,w)
  def add_edge(self,u,v,w):
    newnode=Node(u,v,w)
    newnode.next=self.adj_list[u]
    self.adj_list[u]=newnode
  def edge_exists(self, u, v):
    temp=self.adj_list[u]
    while temp!=None:
      if temp.v==v:
        return False
      temp=temp.next
    return True
  def convert_undrect(self):
    for i in self.adj_list:
      temp=i
      while temp!=None:
        v1=temp.u
        u1=temp.v
        if self.edge_exists(u1,v1):
          self.add_edge(u1,v1,temp.w)
        temp=temp.next
  def print_list(self):
        print( "indirect Adjacency List with Weights:")
        for i in self.adj_list:
          temp=i
          print(temp.u,end=':')
          while temp!=None:
            if temp.next==None:
              print(f"({temp.v},{temp.w})")
            else:
              print(f"({temp.v},{temp.w})",end=",")
            temp=temp.next
# Driver code
num_vertices=7
edges=[(0, 1, 4), (0, 2, 3), (0, 3, 2), (1, 2, 5), (1, 4, 7), (1, 5, 6),
    (2, 3, 4), (2, 6, 8), (3, 4, 2), (3, 6, 5), (4, 5, 1), (4, 6, 6),
    (5, 6, 3), (5, 0, 2), (6, 1, 4), (6, 0, 7)]
graph=Graph(num_vertices)
graph.add_edges(edges)
graph.convert_undrect()
graph.print_list()