# -*- coding: utf-8 -*-
"""cse220 heap lab 8

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VAb-_ndm90bHhqDxk8NpPoyX8HhB6V0v
"""

import numpy as np
class MaxHeap:
  def __init__(self,heap_length=10):#array banabe cz heap array er sthe related.. r array er length/size default fixed kre dichi heap cls e
    self.heap = np.array([None] * (heap_length + 1))
    self.last_index=1#j idx e new value insert hbe.. apatoto array te value 0 sob idx e.. cz value insert hoyni still. just len=10 die array creat hoise.
    #ti initially last idx=1 dhorlam.. cz 0 idx None thak e heap e. tile insert hoar first idx=1
  def insert(self,inserted_value):#######insert e first e insert then swim#############
    # inserted_value=jei value insert krbo
    if self.last_index>=len(self.heap):#array te insert krar mto new value sei space ase kina sei condition chq krtse. jdi last_idx>=hoy heap er lentgh theke tile
    #oi heap/array te new value insert psbl na.cz array er size fixed. jdi array er last idx eo value thake tile new kisu insert hbena
# self.heap is initially: [None, None, None, None] (length = 4, for len 4.. idx num are=0,1,2,3)... heap is also a array
# Valid insert positions: 1, 2, 3.. heap e 0 idx None thake alws.#############
# Step by step: idx=1 e insert start hoy heap er array te. so first insertion at idx 1
# Insert 10(insert at idx 1 → heap = [None,10, None, None], last_index = 2#last_index holo jekahne value ase array er tar porer index. means jekhane new value akhn insert kra jabe.value ase idx=1 e . last idx=2 tahole
# Insert 20(insert at idx 2) → heap = [None,10, 20, None], last_index = 3
# Insert 30(insert at idx 3) → heap = [None,10, 20, 30], last_index = 4
# Insert 40 → last_index = 4, len(heap) = 4 → ❌ heap is full.. cz array te idx=4 nei ..ase 0,1,2,3.. so idx 4  nei ti ekhane insert o psbl na. len(heap) theke idx 1 kom hoy..
#jamon len(heap)=4 and idx=0,1,2,3
      print("no space left in heap")
      return
    self.heap[self.last_index]=inserted_value#last idx e value insert hbe. initially last idx=1
    self.swim(self.last_index)#swim e last index jabe heap er..last index=child node er index.(2i or 2i+1)
    self.last_index+=1#value insert hoe gele last idx 1 kre barbe. cz sei idx e next value bosbe
    print("insertted succesfully")
  def swim(self, child_index):#child to parent chq kra.parent<child hole swap kra. dn upore uthe parent k child dhore tar parent evabe chq kra..
  #ecvabe krte krte eksomoy root e chole jabe jar kono parent r ni ti parent<child kina chq krar way ni ti swap func end hbe tkhn
    if child_index == 1:#base case.. swim krte krte jkhn index means root e chole asbe tkhn r swim hbena. cz root er kono parent node ni so no swap.
        return
    parent_index = child_index // 2#parent idx=i,child idx=2i..1st if e jkhn dhuklona means child er akhno parent ase cz child root na. ti child er abar parent er idx ber krtesi
    if self.heap[parent_index] < self.heap[child_index]:  # max-heap condition. jodi parent value<chld value dn swap
        # Swap parent and child.. parent k child and child k parent banano
        temp = self.heap[parent_index]#jate parent value haraye na jay. cz next line e parent value er jaygay child value bosche
        self.heap[parent_index] = self.heap[child_index]
        self.heap[child_index] = temp
        # Recursively swim up
        self.swim(parent_index)#swim kre upore uthbo. ei parent akhn child hoe jabe. er abar parent akhn dkhbo j parent<child(recent jei parent pass krsi oita akhn child. cz oitar abar parent chq krbo.)
    return#ei return na dileo hbe
  def remove(self):#########first e rmv then sink##########
    #rmv hoy root. but root er sthe last index value swap hoy. then last index(jeta age root silo) seta rmv hoy
    if self.last_index == 1:#base case#####heap array te element insert hoyni. so tkhn rmv o krar drkr ni.
        print("nothng is in the heap to removie or can say heap is empty")
        return
    # swap
    temp = self.heap[1]#root store krlam
    self.heap[1] = self.heap[self.last_index-1]#root e last idx er ager idx e value bosalam. (self.heap[self.last_index]) eta hbena cz swap hoche nd last idx e to value thakena so swap kivabe hbe root er sthe.
    #last idx e just bujhano hoe j jar ager idx e value ase nd last idx e next new kono value insert kra jabe. swap er khetre value swap hoe. to last er ager idx er sthe value swap hpy. ti last idx-1
    self.heap[self.last_index-1] = temp#last idx er ager idx (jetay value ase) e root er value rakhlam
    #self.last_index-1 here -1 cz. akhn last idx e value nei. cz insert e value insert krar por last e last idx+=1 kre 1 baraye dea hoise.so last idx e insert func theke ber hoe rmv func e ashar por e value ni
    self.last_index -= 1#rmving last index. so last idx er value o rmv hoe galo.. mean age jeta root silo
    self.sink(1)#sink func e parent node jabe. jeta idx 1 e ase setai root. root theke chq krte krte (parent>child) sink kre niche jabo
    print(f"{temp} is removed succesfully")
    return temp
  def sink(self, parent_index):#value gulak max heap banate sink kre kre parent>chil ei obztahy anbo
    #parent idx=root niche
    left_index = 2 * parent_index#left child or parent idx=2i
    right_index = 2 * parent_index + 1#r8 child idx=2i+1
    if left_index >= self.last_index and right_index >= self.last_index:##base case########oi parent er child ase kina seta chq krtese. jodi na thake tkhn ei condition e dhukbe.
    #left_index>=self.last_index tkhn left idx out of range hbe. means array te nei means
    #left child e ni. = hileo same case. cz l and r child thakte hole last idx theke choto hote hbe l and r idx er num. (cz last idx means jekahne last value ase tar porer idx)
        return
    elif left_index < self.last_index and right_index < self.last_index:#jodi l and r child duiti thake thake
        #swap between l child and paren when l child>parent
        if self.heap[left_index] > self.heap[right_index]:#l and r er mdhe l boro hoile l bosbe parent node e
            temp = self.heap[left_index]#jeta parent e bosbe oitak alws temp e rakhbo
            self.heap[left_index] = self.heap[parent_index]
            self.heap[parent_index] = temp
            self.sink(left_index)#l idx parent idx er jaygay send krsi. cz akhn abar niche neme means sink kre etar aabr child nodes chq kre same vabe . j parent<l or r child theke
        else:#r child>l child hole .. r child and parent swap hbe
            temp = self.heap[right_index]
            self.heap[right_index] = self.heap[parent_index]
            self.heap[parent_index] = temp
            self.sink(right_index)#same like previosu l child
    elif left_index < self.last_index:#sudhu jdi left child thake..r8 child jdi na thake
        temp = self.heap[left_index]
        self.heap[left_index] = self.heap[parent_index]
        self.heap[parent_index] = temp
        self.sink(left_index)
    #sudhu r8 child chq er pryojon nei cz left na thakle r8 child o thakbena
    return
  def heap_sort(self):#just
    sorted_array = np.zeros(self.last_index - 1)#self.last_index - 1 eta die sorted array er size create kra hoche. -1 kri cz array er size last idx theke 1 kom hbe
    for i in range(len(sorted_array)):#array te initially kono value ni. sob None
        sorted_array[i] = self.remove()#max value remove hoe self.remove() ei jaygay astese. nd sorted array er index e oita bostese.
    return sorted_array#sorted array creation ses akhn return krtesi array
#driver code
heap = MaxHeap(5)#size of array ba heap bola jay=5.. here indexes=0,1,2,3,4,5... size and length of a array isnt same. size total indexes. len total idx+1
#at idx=None its alws None. so value can b inserted at idx=1,2,3,4,5... the len(heap)=6. if idx=>len(heap)= then value cant be inserted

heap.insert(15)#inserted at idx=1, so now last_idx=2
heap.insert(5)#inserted at idx=2, so now last_idx=3
heap.insert(20)
heap.insert(15)
heap.insert(10)#inserted at idx=5, so now last_idx=6
heap.insert(24)  #needt to insert at idx=6. bt idx=len(heap), so cant insert Output: No space left in heap
#insert hoar por max heap maintain (paren>child node) hoe jabe auto swim func e..
# Remove hbe first e root(means max value.. cz max value e root e thake heap er.).. serially max value/root e rmv hbe
print(heap.heap_sort())
heap.remove()  # Output: 20 is removed successfully...

# Remove next max (should be 15)
heap.remove()  # Output: 15 is removed successfully...

# Insert a new element (now there's space)
heap.insert(100) #akhn eta root hoe jabe. cz eta max
heap.remove()#max 100 sob inserted value er mdhe ti etai rmv hbe

import numpy as np
class MaxHeap:
  def __init__(self,heap_length=10):
    self.heap = np.array([None] * (heap_length + 1))
    self.last_index=1

  def insert(self,inserted_value):
    if self.last_index>=len(self.heap):
      print('no space')
      return
    else:
      self.heap[self.last_index]=inserted_value
      print(f'{inserted_value}inserted')
      self.swim(self.last_index)
      self.last_index+=1
      return

  def swim(self,childidx):
    if childidx==1:
      return
    parentidx=childidx//2
    if self.heap[parentidx]<self.heap[childidx]:   # ✅ fixed chlidx → childidx
      temp=self.heap[parentidx]
      self.heap[parentidx]=self.heap[childidx]
      self.heap[childidx]=temp
      self.swim(parentidx)
    return

  def remove(self):
    if self.last_index==1:
      print('nothing to rmv')
      return
    else:
      rmvval=self.heap[1]
      self.heap[1],self.heap[self.last_index-1]=self.heap[self.last_index-1],self.heap[1]
      self.last_index-=1
      print(f'{self.heap[self.last_index]}removed')
      self.sink(1)
      return rmvval
  def sink(self,parentidx):
    leftidx=2*parentidx
    rightidx=2*parentidx+1
    if leftidx>=self.last_index: # rightidx>=self.last_index:#left na thakle r8 o thakbena ti eta chq krai enough
      return
    if leftidx<self.last_index and rightidx<self.last_index:
      if self.heap[leftidx]>self.heap[rightidx]:
        if self.heap[parentidx]<self.heap[leftidx]:   #fixed sign
          self.heap[parentidx],self.heap[leftidx]=self.heap[leftidx],self.heap[parentidx]
          self.sink(leftidx)
      else:
        if self.heap[parentidx]<self.heap[rightidx]:  #fixed sign
          self.heap[parentidx],self.heap[rightidx]=self.heap[rightidx],self.heap[parentidx]
          self.sink(rightidx)
    elif leftidx<self.last_index and rightidx>=self.last_index:
      if self.heap[parentidx]<self.heap[leftidx]:     #fixed condition
        self.heap[parentidx],self.heap[leftidx]=self.heap[leftidx],self.heap[parentidx]
        self.sink(leftidx)
  def heap_sort(self):
    # sortheap=[0]*(self.last_index-1)
    sortheap=[0]*(len(self.heap)-1)
    for i in range(len(sortheap)):
      sortheap[i]=heap.remove()
    return sortheap
#driver code
heap = MaxHeap(5)#size of array ba heap bola jay=5.. here indexes=0,1,2,3,4,5... size and length of a array isnt same. size total indexes. len total idx+1
#at idx=None its alws None. so value can b inserted at idx=1,2,3,4,5... the len(heap)=6. if idx=>len(heap)= then value cant be inserted

heap.insert(15)#inserted at idx=1, so now last_idx=2
heap.insert(5)#inserted at idx=2, so now last_idx=3
heap.insert(20)
heap.insert(15)
heap.insert(10)#inserted at idx=5, so now last_idx=6
heap.insert(24)  #needt to insert at idx=6. bt idx=len(heap), so cant insert Output: No space left in heap
#insert hoar por max heap maintain (paren>child node) hoe jabe auto swim func e..
# Remove hbe first e root(means max value.. cz max value e root e thake heap er.).. serially max value/root e rmv hbe
print(heap.heap_sort())
heap.remove()  # Output: 20 is removed successfully...

# Remove next max (should be 15)
heap.remove()  # Output: 15 is removed successfully...

# Insert a new element (now there's space)
heap.insert(100) #akhn eta root hoe jabe. cz eta max
heap.remove()#max 100 sob inserted value er mdhe ti etai rmv hbe

#same code above one. but wihout sorted array func.. just fresh one
import numpy as np
class MaxHeap:
    def __init__(self, heap_length=10):
        self.heap = np.array([None] * (heap_length + 1))
        self.last_index = 1  # Next insert position..
    def insert(self, inserted_value):
        if self.last_index >= len(self.heap):
            print("No space left in heap")
            return
        self.heap[self.last_index]=inserted_value
        print(f"{inserted_value} is inserted successfully...")
        self.swim(self.last_index)
        self.last_index += 1
        #print(f"{inserted_value} is inserted successfully...")
    def swim(self, child_index):
        if child_index == 1:
            return
        parent_index = child_index // 2#child idx=2i, parent idx=2i//2=i
        if self.heap[parent_index] < self.heap[child_index]:
            temp = self.heap[parent_index]
            self.heap[parent_index] = self.heap[child_index]
            self.heap[child_index] = temp
            self.swim(parent_index)
        return#ei return na dileo hoy
    def remove(self):
        if self.last_index == 1:
            print("nothing to remove in the heap")
            return
        temp = self.heap[1]
        self.heap[1] = self.heap[self.last_index - 1]
        self.heap[self.last_index - 1] = temp
        self.last_index -= 1
        self.sink(1)
        print(f"{temp} is removed successfully...")
        return
    def sink(self, parent_index):
        left_index = 2 * parent_index
        right_index = 2 * parent_index + 1
        if left_index >= self.last_index and right_index >= self.last_index:
            return
        elif left_index < self.last_index and right_index < self.last_index:
            if self.heap[left_index] > self.heap[right_index]:
                temp = self.heap[left_index]
                self.heap[left_index] = self.heap[parent_index]
                self.heap[parent_index] = temp
                self.sink(left_index)
            else:
                temp = self.heap[right_index]
                self.heap[right_index] = self.heap[parent_index]
                self.heap[parent_index] = temp
                self.sink(right_index)
        elif left_index < self.last_index:
            temp = self.heap[left_index]
            self.heap[left_index] = self.heap[parent_index]
            self.heap[parent_index] = temp
            self.sink(left_index)
        return
heap = MaxHeap(5)
heap.insert(15)
heap.insert(5)
heap.insert(20)
heap.insert(15)
heap.insert(10)

heap.insert(24)  # Output: No space left in heap
heap.remove()  # Output: 20 is removed successfully...

# Remove next max (should be 15)
heap.remove()  # Output: 15 is removed successfully...

# Insert a new element (now there's space)
heap.insert(100) #akhn eta root hoe jabe. cz eta max
heap.remove()#max 100 sob inserted value er mdhe ti etai rmv hbe

#task2
import numpy as np
class MaxHeap:
    def __init__(self, heap_length=10):
        self.heap = np.array([None] * (heap_length + 1))
        self.last_index = 1
    def insert(self, inserted_value):
        if self.last_index >= len(self.heap):
            print("No space left in heap")
            return
        self.heap[self.last_index]=inserted_value
        print(f"{inserted_value} is inserted successfully...")
        self.swim(self.last_index)
        self.last_index += 1
    def swim(self, child_index):
        if child_index == 1:
            return
        parent_index = child_index // 2#child idx=2i, parent idx=2i//2=i
        if self.heap[parent_index] < self.heap[child_index]:
            temp = self.heap[parent_index]
            self.heap[parent_index] = self.heap[child_index]
            self.heap[child_index] = temp
            self.swim(parent_index)
        return
    def remove(self):
        if self.last_index == 1:
            print("nothing to remove in the heap")
            return
        temp = self.heap[1]
        self.heap[1] = self.heap[self.last_index - 1]
        self.heap[self.last_index - 1] = temp
        self.last_index -= 1
        self.sink(1)
        print(f"{temp} is removed successfully...")
        return temp
    def sink(self, parent_index):
        left_index = 2 * parent_index
        right_index = 2 * parent_index + 1
        if left_index >= self.last_index and right_index >= self.last_index:
            return
        elif left_index < self.last_index and right_index < self.last_index:
            if self.heap[left_index] > self.heap[right_index]:
                temp = self.heap[left_index]
                self.heap[left_index] = self.heap[parent_index]
                self.heap[parent_index] = temp
                self.sink(left_index)
            else:
                temp = self.heap[right_index]
                self.heap[right_index] = self.heap[parent_index]
                self.heap[parent_index] = temp
                self.sink(right_index)
        elif left_index < self.last_index:
            temp = self.heap[left_index]
            self.heap[left_index] = self.heap[parent_index]
            self.heap[parent_index] = temp
            self.sink(left_index)
        return
    def heap_sort(self):
      sorted_array = np.zeros(self.last_index - 1)
      for i in range(len(sorted_array)):
          sorted_array[i] = self.remove()
      return sorted_array
heap = MaxHeap(5)
heap.insert(15)
heap.insert(5)
heap.insert(20)
heap.insert(15)
heap.insert(10)
heap.insert(24)
print(f"sorter_array{(heap.heap_sort())}")

########heap size and array size are nt same##########3
heap = MaxHeap(5)#self.heap = [None, None, None, None, None, None]
heap.insert(10)#inserted at idx=1. now last_index=2
heap.insert(20)#inserted at idx=2(which was last index)... now last_index=2
self.heap = [None, 20, 10, None, None, None]
len(self.heap) = 6
self.last_index = 3

  #but
Heap contains 2 values: self.heap[1] and self.heap[2]

Heap size = last_index - 1 = 2

#but Array size = 6, len(self.heap) = 6, Heap size=2
so array and heap size are different. but array size and len of heap are same

#task1
import numpy as np
class MinHeap:
    def __init__(self, heap_length=10):
        self.heap = np.array([None] * (heap_length + 1))
        self.last_index = 1
    def insert(self, inserted_value):
        if self.last_index >= len(self.heap):
            print("No space left in heap")
            return
        self.heap[self.last_index] = inserted_value
        print(f"{inserted_value} is inserted successfully...")
        self.swim(self.last_index)
        self.last_index += 1
    def swim(self, child_index):
        if child_index == 1:
            return
        parent_index = child_index // 2
        if self.heap[parent_index] > self.heap[child_index]:
            temp = self.heap[parent_index]
            self.heap[parent_index] = self.heap[child_index]
            self.heap[child_index] = temp
            self.swim(parent_index)
    def remove(self):
        if self.last_index == 1:
            print("Nothing to remove in the heap")
            return
        temp = self.heap[1]
        self.heap[1] = self.heap[self.last_index - 1]
        self.heap[self.last_index - 1] = temp
        self.last_index -= 1
        self.sink(1)
        print(f"{temp} is removed successfully...")
        return temp
    def sink(self, parent_index):
        left_index = 2 * parent_index
        right_index = 2 * parent_index + 1
        if left_index >= self.last_index and right_index >= self.last_index:
            return
        elif left_index < self.last_index and right_index < self.last_index:
            if self.heap[left_index] < self.heap[right_index]:
                if self.heap[parent_index] > self.heap[left_index]:
                    temp = self.heap[left_index]
                    self.heap[left_index] = self.heap[parent_index]
                    self.heap[parent_index] = temp
                    self.sink(left_index)
            else:
                if self.heap[parent_index] > self.heap[right_index]:
                    temp = self.heap[right_index]
                    self.heap[right_index] = self.heap[parent_index]
                    self.heap[parent_index] = temp
                    self.sink(right_index)
        elif left_index < self.last_index:
            if self.heap[parent_index] > self.heap[left_index]:
                temp = self.heap[left_index]
                self.heap[left_index] = self.heap[parent_index]
                self.heap[parent_index] = temp
                self.sink(left_index)
    def heap_sort(self):
        sorted_array = [0]*(self.last_index - 1)
        for i in range(len(sorted_array)):
            sorted_array[i] = self.remove()
        return sorted_array
# Driver code
heap = MinHeap(5)
heap.insert(15)
heap.insert(5)
heap.insert(20)
heap.insert(15)
heap.insert(10)
heap.insert(2)
print(heap.heap_sort())

#task3
# import numpy as np
# class MinHeap:
#     def __init__(self, heap_length):
#         self.heap = np.array([None] * (heap_length + 1))
#         self.last_index = 1
#     def insert(self, inserted_value):
#         if self.last_index >= len(self.heap):
#             return
#         self.heap[self.last_index] = inserted_value
#         self.swim(self.last_index)
#         self.last_index += 1
#     def swim(self, child_index):
#         if child_index == 1:
#             return
#         parent_index = child_index // 2
#         if self.heap[parent_index] > self.heap[child_index]:
#             self.heap[parent_index], self.heap[child_index] = self.heap[child_index], self.heap[parent_index]
#             self.swim(parent_index)
#     def remove(self):
#         if self.last_index == 1:
#             return None
#         temp = self.heap[1]
#         self.heap[1] = self.heap[self.last_index - 1]
#         self.heap[self.last_index - 1] = temp
#         self.last_index -= 1
#         self.sink(1)
#         return temp
#     def sink(self, parent_index):
#         left_index = 2 * parent_index
#         right_index = 2 * parent_index + 1
#         if left_index >= self.last_index and right_index >= self.last_index:
#             return
#         elif left_index < self.last_index and right_index < self.last_index:
#             if self.heap[left_index] < self.heap[right_index]:
#                 if self.heap[parent_index] > self.heap[left_index]:
#                     self.heap[parent_index], self.heap[left_index] = self.heap[left_index], self.heap[parent_index]
#                     self.sink(left_index)
#             else:
#                 if self.heap[parent_index] > self.heap[right_index]:
#                     self.heap[parent_index], self.heap[right_index] = self.heap[right_index], self.heap[parent_index]
#                     self.sink(right_index)
#         elif left_index < self.last_index:
#             if self.heap[parent_index] > self.heap[left_index]:
#                 self.heap[parent_index], self.heap[left_index] = self.heap[left_index], self.heap[parent_index]
#                 self.sink(left_index)
    # def heap_sort(self):
    #     sorted_array = np.zeros(self.last_index - 1, dtype=int)
    #     for i in range(len(sorted_array)):
    #         sorted_array[i] = self.remove()
    #     return sorted_array
def distribution(steps, m):
    heap = MinHeap(m)#[None,None,None,None,]
    for i in range(m):#i=0,1,2,3
        heap.insert(0)
    #heap=[0, 0, 0, 0]after finishing the first for loop
    for j in steps:
        min_task = heap.remove()
        heap.insert(min_task + j)
    return heap.heap_sort()
# DRIVER CODE
steps= [2, 4, 7, 1, 6]
m = 4
result = distribution(steps, m)
print(result)#[2. 4. 7. 7.]
#       1
#     /   \
#    2     7
#   /
#  4  here when insrerting 4..it will go to level 2 and from left. thats mean will go to the left of 2. as heap follows balanced binary tree. which insert value starting from left and parent>child
#jdio [2 4 7 7] eta sorted na krleo sorted obzthay e paoa jache bt onno example use krle kaj nao krte pare ti sort kre nibo


#a example to understand why need to sort***** =a minheap tree=[1,  3,  5,  4,  6].. its not sorted. because sorted in min heap means values choto theke boro te jabe slowly bt 5>4
  #       1
  #     /   \
  #    3     5
  #   / \
  #  4   6
#for 74-78 line tree.. now if i sort the minheap it will be=[1, 3, 4, 5, 6]..
#there is a difference in proper min tree and sorted minheap

#task3
def distribution(tasks, m):
  heap=MinHeap(m)
  for i in range(m):
    heap.insert(0)
  for j in tasks:
#     heap.insert(heap.remove()+j)
#   return heap.heap_sort()
# DRIVER CODE
   n=heap.remove()
   heap.insert(n+j)
  return heap
# DRIVER CODE
tasks= [2, 4, 7, 1, 6]
m = 4
result = distribution(tasks, m)
print(result)#[2. 4. 7. 7.]

def dis(steps, m):
    heap = MinHeap(m)
    for i in range(m):
        heap.insert(0)
    for j in steps:
        min_task = heap.remove()
        heap.insert(min_task + j)
    return heap.heap_sort()
step= [2, 4, 7, 1, 6]
m = 4
result = dis(step, m)
print(result)

#task3 alter
def distribution(steps, m):
    heap = MinHeap(m)#[None,None,None,None,]
    for i in range(m):#i=0,1,2,3
        heap.insert(0)
    for j in steps:
      heap.insert(heap.remove()+j)#############
    return heap.heap_sort()
# DRIVER CODE
steps= [2, 4, 7, 1, 6]
m = 4
result = distribution(steps, m)
print(result)

#xxxxxxxxxxxxxxxheap(max/min)doesnt allow adding new value by ***indexing***. bcz it may break the condition parent<child or parent>child.
#so new value add e only ****insert***** is allows in heap
def distribution(steps, m):
    heap = MinHeap(m)#[None,None,None,None,]
    for i in range(m):
      #heap.insert(0)
      heap[i]=0#xxxxxxxxxxxxxxxxxxxx
    for j in steps:
      heap.insert(heap.remove()+j)
    return heap
# DRIVER CODE
steps= [2, 4, 7, 1, 6]
m = 4
result = distribution(steps, m)
print(result)

#task3xxxxxxxxxxxxxxx
def distribution(steps, m):
    heap = MinHeap(m)#[None,None,None,None,]
    for i in range(m):#i=0,1,2,3
        heap.insert(0)
    for j in steps:
      heap.insert(heap.remove()+j)
    return heap#returning the heap object, which is an object of the MinHeap class. print(object/heap)=adress print hbe. nd setai hoise output e.
    #we need to print the element in the heap object
# DRIVER CODE
steps= [2, 4, 7, 1, 6]
m = 4
result = distribution(steps, m)
print(result)

#task4***************8
def findmax(n, k):
    heap=MaxHeap(len(n))
    for j in n:
        heap.insert(j)#alws given input list theke elements heap e insert krte hbe
   # out=np.array('i', [0] * k)
    out=[0]*k
    for idx in range(k):
        out[idx]=heap.remove()
    return out
n=[4, 10, 2, 8, 6, 7]
k=3
print(findmax(n, k))#

#task4***************8
def findmax(n, k):
  heap=MaxHeap(len(n))
  for i in n:
    heap.insert(i)
  arr=[0]*k
  for j in range(k):
    arr[j]=heap.heap_sort()
  return arr
n=[4, 10, 2, 8, 6, 7]
k=3
print(findmax(n, k))

def findmax(nums,k):
    heap=MaxHeap(len(nums))
    for j in nums:
        heap.insert(j)#alws given input list theke elements heap e insert krte hbe
   # out=np.array('i', [0] * k)
    out=[0]*k
    for idx in range(k):
        out[idx]=heap.remove()
    return out
nums=[4, 10, 2, 8, 6, 7]
k=3
print(findmax(nums, k))#[10, 8, 7]

def findmax(n, k):
  heap=MaxHeap(len(n))
  for i in n:
   heap.insert(i)
  arr=[0]*k
  for j in range(k):
    arr[j]=heap.heap_sort()
  return arr
n=[4, 10, 2, 8, 6, 7]
k=3
print(findmax(n, k))

def findmax(n, k):
  heap=MinHeap(len(n))
  for i in n:
    heap.insert(i)
  arr=[0]*k
  for j in range(k):
    arr[j]=heap.remove()
  return arr
n=[4, 10, 2, 8, 6, 7]
k=3
print(findmax(n, k))