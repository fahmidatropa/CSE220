# -*- coding: utf-8 -*-
"""cse220 lab3 dubbly LL

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ctovJoIPxKcFtQHIgqhKFoCSXmpeIWj_

# Lab Task

### Lab Task Class Design [NO NEED TO SUBMIT]
"""

class Patient:
    #write the constructor
    def __init__(self, id, name, age, bloodgroup, next, prev):
        pass

class WRM:

    #here the constructor is already written for you
    def __init__(self):
        #Creating the dummy head, that's all this constructor will do
        self.dh = Patient(None,None,None,None,None,None)
        self.dh.next = self.dh
        self.dh.prev = self.dh

    def registerPatient(self,id, name, age, bloodgroup):
        #To Do
        pass

    def servePatient(self):
        #To Do
        pass

    def showAllPatient(self):
        #To Do
        pass

    def canDoctorGoHome(self):
        #To Do
        pass

    def cancelAll(self):
        #To Do
        pass

    def ReverseTheLine(self):
        #To Do
        pass

"""### Lab Task Driver Code


`
after each operation you can choose option 5 to check whether your operation was correct or not
`
"""

#DO NOT MODIFY THIS CELL AT ALL!!!!!!!
#ONLY MAKE MODIFICATION IN THE CELL ABOVE
#JUST RUN THIS CELL TO TEST YOUR CODE
def print_options():
    print("==Choose an Option==")
    print("1. RegisterPatient()")
    print("2. ServePatient()")
    print("3. CancelAll()")
    print("4. CanDoctorGoHome()")
    print("5. ShowAllPatient()")
    print("6. ReverseTheLine()")
    print("7. exit")
    print("=====================")

print("**Welcome to Waiting Room Management System**")
wrm = WRM()
while True:
    print_options()
    x = input('Enter your choice:  ')
    if x=='1':
        print("executing RegisterPatient()...")
        print()
        id = int(input('Enter ID: '))
        name = (input('Enter Name: '))
        age = int(input('Enter Age: '))
        bloodgroup = (input('Enter Blood group: '))
        wrm.registerPatient(id,name,age,bloodgroup)
    elif x=='2':
        print("executing ServePatient()...")
        print()
        wrm.servePatient()
    elif x=='3':
        print("executing CancelAll()...")
        wrm.cancelAll()
    elif x=='4':
        print("executing CanDoctorGoHome()...")
        print(wrm.canDoctorGoHome())
    elif x=='5':
        print("executing ShowAllPatient()...")
        wrm.showAllPatient()
    elif x=='6':
        print("executing ReverseTheLine()...")
        wrm.ReverseTheLine()
    elif x=='7':
        print("\nThank You For Using \"Waiting Room Management System\"")
        break
    else:
        print("No Such Option")
    print()

"""# Assignment Task

### Helper Codes [Must Run for the Tester Code to Work] **[DO NOT SUBMIT]**
"""

### Helper Codes [Must Run for the Tester Code to Work]
# YOU MUST RUN THIS CELL FOR THE TESTER CODES TO WORK
# DO NOT MODIFY THIS CELL!!!
# IF YOU FIND ANY ISSUES PLEASE CONTACT AIB
class Node:
  def __init__(self, elem):
    self.elem = elem
    self.next = None
### Helper Codes [Must Run for the Tester Code to Work]
class DNode:
  def __init__(self, elem):
    self.elem = elem
    self.next = None
    self.prev = None
### Helper Codes [Must Run for the Tester Code to Work]
def createDummyHeadedDoublyLL(values, circular=False):
    dHead = DNode(None)
    n = dHead
    # Create and link all value nodes
    for val in values:
        new_node = DNode(val)
        n.next = new_node
        new_node.prev = n
        n = new_node
    if circular:
        n.next = dHead
        dHead.prev = n
    return dHead
### Helper Codes [Must Run for the Tester Code to Work]
def createDummyHeadedSinglyCircularLL(values, circular=False):
    dHead = Node(None)
    n = dHead
    for val in values:
        new_node = DNode(val)
        n.next = new_node
        n = new_node
    # Make it circular
    if circular:
        n.next = dHead
    return dHead
### Helper Codes [Must Run for the Tester Code to Work]
def printDummyHeadedSinglyCircularLL(head):
    print("[X]", end = ' --> ')
    n = head.next
    while n != head:
        print(f'[{n.elem}]', end = ' --> ')
        n = n.next
    print("(back to start)")
### Helper Codes [Must Run for the Tester Code to Work]
def printDummyHeadedDoublyLL(head):
    print("Forward: ",end="")
    print("[X]", end = ' --> ')
    n = head.next
    lstNode = None
    while n != None:
        print(f'[{n.elem}]', end = ' --> ')
        if( n.next == None ):
            lstNode = n
        n = n.next
    print("(back to start)")
    print("Backward: ",end="")
    n = lstNode
    while n != None and n.elem !=None:
        print(f'[{n.elem}]', end = ' --> ')
        n = n.prev
    print("[X] --> (back to end)\n")
### Helper Codes [Must Run for the Tester Code to Work]
def printDummyHeadedDoublyCircularLL(head):
    print("Forward: ",end="")
    print("[X]", end = ' --> ')
    n = head.next
    lstNode = None
    while n != head:
        if n==None :
            print("\n[ERROR!!] NOT CIRCULAR!!!")
            return
        print(f'[{n.elem}]', end = ' --> ')
        n = n.next
    print("(back to start)")
    print("Backward: ",end="")
    n = head.prev
    if n==None:
        print("[ERROR!!] No PREV Connecion from HEAD")
        return
    while n != head:
        print(f'[{n.elem}]', end = ' --> ')
        n = n.prev
    print("[X] --> (back to end)\n")
### Helper Codes [Must Run for the Tester Code to Work]

"""### Assignment Task 5 [Must Submit]"""

def sumOddAppend( head ):
    pre=head
    temp=head.next
    sum=0
    while temp!=head:
      if temp.elem%2!=0:
        pre.next=temp.next
        temp.next.prev=pre
        sum+=temp.elem
        temp=pre.next
      else:
        pre=temp
        temp=temp.next
    newNode = Node(sum)
    pre.next = newNode
    newNode.next = head

"""#### Assignment Task 5 (Tester Code) **[DO NOT Submit]**"""

head = createDummyHeadedSinglyCircularLL( [11,22,33,44,55,66], True)
print("Given Linked List: ")
printDummyHeadedSinglyCircularLL(head)
print("\nExpected Output: ")
expectedHead = createDummyHeadedSinglyCircularLL( [22,44,66,99], True)
printDummyHeadedSinglyCircularLL(expectedHead)
#Running the Sum Odd Append
sumOddAppend(head)
#Printing after Sum Odd Append
print("\nYour Output: ")
printDummyHeadedSinglyCircularLL(head)

"""### Assignment Task 6 [Must Submit]"""

def pairJoin( dh1, dh2 ):#same for singly LL, dubbly LL, dummy headed circular dubbly LL
  temp1=dh1.next#11
  temp2=dh2.next#4
  while temp1!=dh1 and temp2!=dh2:
    cur1=temp1.next#dh1
    cur2=temp2.next#dh2
    temp1.next=temp2
    temp2.prev=temp1#11=4
    temp2.next=cur1
    cur1.prev=temp2#
    temp1=cur1
    temp2=cur2
  return dh1

"""#### Assignment Task 6 (Tester Code) **[DO NOT Submit]**"""

dh1 = createDummyHeadedDoublyLL( ['A', 'B', 'C', 'D'], False )
dh2 = createDummyHeadedDoublyLL( ['E', 'F', 'G', 'H'], False )
print("Given Linked List 1: ")
printDummyHeadedDoublyLL(dh1)
print("Given Linked List 2: ")
printDummyHeadedDoublyLL(dh2)
print("\nExpected Output: ")
expectedHead = createDummyHeadedDoublyLL( ['A','E','B','F','C','G','D','H'], True)
printDummyHeadedDoublyCircularLL(expectedHead)
#Running the Pair Join
pairJoin(dh1,dh2)
#Printing after Pair Join
print("\nYour Output: ")
printDummyHeadedDoublyCircularLL(dh1)

"""### Assignment Task 7 [Must Submit]"""

def rangeMove( dhead1, start, end ):
  cur = dhead1.next
  lastinrange = None
  while cur != dhead1:
    if start <= cur.elem <= end:
      cur.prev.next = cur.next
      cur.next.prev = cur.prev
      n1 = cur.next
      if lastinrange == None:
        temp = dhead1.next
        while temp != dhead1:
          if temp.next == dhead1:
            lastinrange = temp
          temp = temp.next
        lastinrange.next = cur
        cur.prev = lastinrange
        cur.next = dhead1
        dhead1.prev = cur
        lastinrange = cur
      else:
        lastinrange.next = cur
        cur.prev = lastinrange
        cur.next = dhead1
        dhead1.prev = cur
        lastinrange = cur
      break
    else:
      cur = cur.next

# def rangeMove( dhead1, start, end ):
  # temp1=dhead1.next
  # tail=None
  # while temp1.next!=dhead1:
  #   temp1=temp1.next
  # tail=temp1
  # temp=dhead1.next
  # while temp!=dhead1:
  #   if start<=temp.elem<=end:
  #     cur1=temp.next
  #     cur=temp
  #     temp.prev.next=temp.next
  #     cur1.prev = temp.prev
  #     tail.next=cur
  #     cur.prev=tail
  #     tail=cur
  #     tail.next=dhead1
  #     dhead1.prev=tail
  #     temp=cur1
  #   else:
  #     temp=temp.next
  # return dhead1
def rangeMove(dhead1, start, end):
    temp1 = dhead1.next
    while temp1.next != dhead1:
        temp1 = temp1.next
    tail = temp1

    temp = dhead1.next
    while temp != dhead1:
        if start <= temp.elem <= end:
            cur = temp
            # ✅ move next AFTER removal
            temp.prev.next = temp.next
            temp.next.prev = temp.prev

            next_node = temp.next  # ✅ do this after removing `temp` safely

            tail.next = cur
            cur.prev = tail
            tail = cur
            tail.next = dhead1
            dhead1.prev = tail

            temp = next_node  # ✅ move forward safely
        else:
            temp = temp.next
    return dhead1

"""#### Assignment Task 7 (Tester Code) **[DO NOT Submit]**"""

dh = createDummyHeadedDoublyLL( [5,3,7,1,9,6,2,4], True )
print("Given Linked List: ")
printDummyHeadedDoublyCircularLL(dh)
print("\nExpected Output: ")
expectedHead = createDummyHeadedDoublyLL( [3,1,9,2,4,5,7,6], True)
printDummyHeadedDoublyCircularLL(expectedHead)
#Running the Range Move with [5,7] range
rangeMove(dh, 5, 7)
#Printing after Range Move
print("\nYour Output: ")
printDummyHeadedDoublyCircularLL(dh)

#2 dubbly circular LL given. rmv those nodes from head1 LL which matches elem of head2 LL. nd return head1.  dont make any chnage in head2 LL.
def removeMatches(head1, head2):
    temp=head1.next
    tail=None
    while temp.next!=head1:
      temp=temp.next
    tail=temp
    c=0
    temp1=head1.next
    while temp1!=head1:
      temp2=head2.next######
      flag=False
      while temp2!=head2:
        if temp1.elem==temp2.elem:
          flag=True
          if c==0:
            #head1=head1.next#xxx cz head1=dummy head. erporer tar position chng krte hbe (jeta main head)
            head1.next=temp1.next
            head1.next.prev=head1
            temp1=head1.next
            break
          elif tail.elem==temp1.elem:
            tail=tail.prev
            tail.next=head1
            head1.prev=tail
            temp1=head1
            break
          else:#temp1=30  ####20-30-40
           cur=temp1.next
           temp1.prev.next=temp1.next#20->40
           temp1.prev.next.prev=temp1.prev#20<-40
           temp1=cur
           break
        #temp2=temp2.next
        else:
          temp2=temp2.next
      if flag==False:
        temp1=temp1.next
        c+=1
    return head1
# Create two dummy headed circular doubly linked lists
head1 = createDummyHeadedDoublyLL([10, 20, 30, 40, 50], circular=True)
head2 = createDummyHeadedDoublyLL([50, 30, 50, 70], circular=True)

print("Before Removal:")
print("List 1:")
printDummyHeadedDoublyCircularLL(head1)
print("List 2:")
printDummyHeadedDoublyCircularLL(head2)

# Call the function
removeMatches(head1, head2)

print("\nAfter Removal:")
print("List 1:")
printDummyHeadedDoublyCircularLL(head1)
print("List 2 (unchanged):")
printDummyHeadedDoublyCircularLL(head2)

def removeMatches(head1, head2):
    temp1=head1.next
    while temp1!=head1:
      temp2=head2.next
      while temp2!=head2:
       if temp1.elem==temp2.elem:
        if head1.next.elem==temp2.elem:#1st node mille head1 er..x-1-2-3
           head1.next=temp1.next
           head1.next.prev=head1
           temp1=head1.next
        elif temp1.next==head1 and temp1.elem==temp2.elem:#temp1=3
          temp1.prev.next=head1
          head1.prev=temp1.prev
          temp1=head1
        elif temp1.elem==temp2.elem:
          cur=temp1.next
          temp1.prev.next=temp1.next#1-3
          cur.prev=temp1.prev
          temp1=cur
       temp2=temp2.next
      temp1=temp1.next
    return head1
# Create two dummy headed circular doubly linked lists
head1 = createDummyHeadedDoublyLL([10, 20, 30, 40, 50], circular=True)
head2 = createDummyHeadedDoublyLL([50, 30, 50, 70], circular=True)

print("Before Removal:")
print("List 1:")
printDummyHeadedDoublyCircularLL(head1)
print("List 2:")
printDummyHeadedDoublyCircularLL(head2)

# Call the function
removeMatches(head1, head2)

print("\nAfter Removal:")
print("List 1:")
printDummyHeadedDoublyCircularLL(head1)
print("List 2 (unchanged):")
printDummyHeadedDoublyCircularLL(head2)