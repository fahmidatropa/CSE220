# -*- coding: utf-8 -*-
"""CSE220 bst

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1e5pamv0BX3LU7rHFW_w-8J4IQ0UmVUUJ
"""

class Node:
    def __init__(self, elem):
        self.elem = elem
        self.left = None
        self.right = None
class BinarySearchTree:
    def __init__(self):
        self.root = None#bst = BinarySearchTree() ##tree er class creat krlam. akhno tree create hyni ti self.root=None ase. insertion e jeye tree create hbe
    # Insert element
    def insert(self, elem):
        self.root = self._insert_recursive(self.root, elem)
    def _insert_recursive(self, node, elem):#self.root=node....node is the current position in the tree where you're trying to insert the new elem.. starting e node=root... nd insertion er surute root==None e silo
        if node is None:
            return Node(elem)#tree er oi position e node=None means node na thakle new node create hoche ei elem die Node cls e
        if elem < node.elem:#leftchild e bosbe kina chq.. if, elif e dhukbe e jokhon oi position e nde!=None
            node.left = self._insert_recursive(node.left, elem)
        elif elem > node.elem:#right child e bosbe kina chq
            node.right = self._insert_recursive(node.right, elem)
        return node #etate prottek bar e last e dhukbe
    #########step by step line######
#insert(30)
# → _insert_recursive(None, 30)
# → node is None → create Node(30)
# → return Node(30)
# → root = Node(30)#last return node line ta kaaj kreni


# insert(10)
# → _insert_recursive(30, 10)
# → 10 < 30 → go left

#   → _insert_recursive(30.left=None, 10)
#   → node is None → create Node(10)
#   → return Node(10)

# → set 30.left = Node(10)
# → return 30


# insert(5)
# → _insert_recursive(30, 5)#1st cl
# → 5 < 30 → go left

#   → _insert_recursive(10, 5)#2nd call
#   → 5 < 10 → go left

#     → _insert_recursive(10.left=None, 5)#3rd call
#     → node is None → create Node(5)
#     → return Node(5)#return for 3rd call

#   → set 10.left = Node(5)
#   → return 10#return for 2nd call

# → return 30# return for 3 rd call
    # Search for an element
    def search(self, elem):
        return self._search_recursive(self.root, elem) #eta search func er diver code er print e retunr hbe nd print krbe

    def _search_recursive(self, node, elem):
        if node is None:
            return False
        if elem == node.elem:
            return True
        elif elem < node.elem:
            return self._search_recursive(node.left, elem)
        else: #elem > node.elem:
            return self._search_recursive(node.right, elem)
    # Delete using Inorder Successor
    def delete_with_successor(self, elem):
        self.root = self._delete_successor(self.root, elem)
    def _delete_successor(self, node, elem):
        if node is None:
            return None
        if elem < node.elem:
            node.left = self._delete_successor(node.left, elem)
        elif elem > node.elem:
            node.right = self._delete_successor(node.right, elem)
        else:
            if node.left is None:
                return node.right
            elif node.right is None:
                return node.left
            successor = self._find_min(node.right)
            node.elem = successor.elem
            node.right = self._delete_successor(node.right, successor.elem)
        return node

    # Delete using Inorder Predecessor
    def delete_with_predecessor(self, elem):
        self.root = self._delete_predecessor(self.root, elem)

    def _delete_predecessor(self, node, elem):
        if node is None:
            return None
        if elem < node.elem:
            node.left = self._delete_predecessor(node.left, elem)
        elif elem > node.elem:
            node.right = self._delete_predecessor(node.right, elem)
        else:
            if node.left is None:
                return node.right
            elif node.right is None:
                return node.left
            predecessor = self._find_max(node.left)
            node.elem = predecessor.elem
            node.left = self._delete_predecessor(node.left, predecessor.elem)
        return node

    def _find_min(self, node):
        while node.left:
            node = node.left
        return node

    def _find_max(self, node):
        while node.right:
            node = node.right
        return node

    # Balance the BST
    def balance(self):
        sorted_array = self._to_sorted_array()
        self.root = self._build_balanced_bst(sorted_array, 0, len(sorted_array) - 1)

    def _build_balanced_bst(self, arr, start, end):
        if start > end:
            return None
        mid = (start + end) // 2
        node = Node(arr[mid])
        node.left = self._build_balanced_bst(arr, start, mid - 1)
        node.right = self._build_balanced_bst(arr, mid + 1, end)
        return node

    def _to_sorted_array(self):
        result = []
        self._inorder_fill(self.root, result)
        return result

    def _inorder_fill(self, node, arr):
        if node is None:
            return
        self._inorder_fill(node.left, arr)
        arr.append(node.elem)
        self._inorder_fill(node.right, arr)

    # In-order print
    def print_in_order(self):
        self._print_in_order(self.root)
        print()

    def _print_in_order(self, node):
        if node is None:
            return
        self._print_in_order(node.left)
        print(node.elem, end=' ')
        self._print_in_order(node.right)

# Example Usage
if __name__ == "__main__":
    bst = BinarySearchTree() #bst holo ekhane ekta speicitfic
    values = [30, 10, 50, 5, 20, 40, 60, 1]
    for v in values:
        bst.insert(v)
#         30 ###tree after insertion###
#        /  \
#      10    50
#     / \    / \
#    5  20  40 60
#   /
#  1

    print("In-order before deletion:")
    bst.print_in_order()

    print("Search 20:", bst.search(20))
    print("Search 100:", bst.search(100))

    bst.delete_with_successor(30)
    print("In-order after deleting 30 using successor:")
    bst.print_in_order()

    bst.insert(30)
    bst.delete_with_predecessor(50)
    print("In-order after deleting 50 using predecessor:")
    bst.print_in_order()

    bst.balance()
    print("In-order after balancing:")
    bst.print_in_order()

#task1
class BTNode:
    def __init__(self, elem):
        self.elem = elem
        self.left = None
        self.right = None
def LCA(root, x, y):
    if root==None:
        return None
    if root.elem == x or root.elem == y:
        return root.elem
    leftlca = LCA(root.left, x, y)
    rightlca = LCA(root.right, x, y)
    if leftlca!=None and rightlca!=None:
        return root.elem
    if leftlca!=None:
        return leftlca
    else:
        return rightlca
# Build the BST as shown in the image
root = BTNode(15)
root.left = BTNode(10)
root.right = BTNode(25)

root.left.left = BTNode(8)
root.left.right = BTNode(12)
root.right.left = BTNode(20)
root.right.right = BTNode(30)

root.left.left.left = BTNode(6)
root.left.left.right = BTNode(9)
root.right.left.left = BTNode(18)
root.right.left.right = BTNode(22)

# Testing all the given LCA cases
print(f"LCA(6,12) = {LCA(root, 6, 12)}")
print(f"LCA(20,6) = {LCA(root, 20, 6)}")
print(f"LCA(18,22) = {LCA(root, 18, 22)}")
print(f"LCA(20,25) = {LCA(root, 20, 25)}")
print(f"LCA(10,12) = {LCA(root, 10, 12)}")

#task2
class BTNode:
    def __init__(self, elem):
        self.elem = elem
        self.left = None
        self.right = None
  #       30
  #      /  \
  #    10    40
  #   /  \   /  \
  #  8   15 35  55
def find_Path(root, key):
    if root==None:
        return "No path found"
    if root.elem==key:
        return [root.elem]
    if key<root.elem:
        left_res=find_Path(root.left,key)
        if left_res!="No path found":#18 nmbr line continue hote hote jokhon root!=None hoe jabe means key match krbe. tkhn bujhbo tree er left side er subtree te key match krena. ti not found die dbo
        #15 line e left_res=[list] or "No path found" hbe
            return [root.elem]+left_res
    if key>root.elem:
        right_res=find_Path(root.right,key)
        if right_res!="No path found":
            return [root.elem] + right_res
    return "No path found"
def tree_construction(arr, i):
    if i >= len(arr) or arr[i] is None:
        return None
    node = BTNode(arr[i])
    node.left = tree_construction(arr, 2*i)
    node.right = tree_construction(arr, 2*i+1)
    return node
# DRIVER CODE
arr = [None, 30, 10, 40, 8, 15, 35, 55]
root = tree_construction(arr, 1)

print(find_Path(root, 15))  # Should print [30, 10, 15]
print(find_Path(root, 50))

#task2xxxxxxxxxxxxxxxxxxx
class BTNode:
    def __init__(self, elem):
        self.elem = elem
        self.left = None
        self.right = None
  #       30
  #      /  \
  #    10    40
  #   /  \   /  \
  #  8   15 35  55
def find_Path(root, key):
    if root==None:
        r="No path found"
    if root.elem==key:
        r=[root.elem]
    if key<root.elem:
        left_res=find_Path(root.left, key)
        if left_res!="No path found":#18 nmbr line continue hote hote jokhon root!=None hoe jabe means key match krbe. tkhn bujhbo tree er left side er subtree te key match krena. ti not found die dbo
        #19 line e left_res=[list] or "No path found" hbe
            r=[root.elem]+left_res#list addition
    if key>root.elem:
        right_res=find_Path(root.right, key)
        if right_res!="No path found":
            r=[root.elem] + right_res
    return r
def tree_construction(arr, i):
    if i >= len(arr) or arr[i] is None:
        return None
    node = BTNode(arr[i])
    node.left = tree_construction(arr, 2*i)
    node.right = tree_construction(arr, 2*i+1)
    return node
# DRIVER CODE
arr = [None, 30, 10, 40, 8, 15, 35, 55]
root = tree_construction(arr, 1)

print(find_Path(root, 15))  # Should print [30, 10, 15]
print(find_Path(root, 50))

#task3
class Node:
    def __init__(self, key):
        self.data = key
        self.left = None
        self.right = None
#          30
#        /    \
#      10      40
#     /  \    /   \
#    3   15 35    55
#   /         \
#  2           36
def sum_of_leaves(root, sum):
    if root==None:
        return sum
    if root.left==None and root.right==None:
        sum += root.data#sum sudhu ekhane chng hoche
        #return sum
    sum=sum_of_leaves(root.left, sum)
    sum=sum_of_leaves(root.right, sum)
    return sum
    ########alternative way#############
    # def sum_of_leaves(root,sum):
    # if root is None:#base case.....leaf node er porer node None.. so setar jnno to kisu sum e add hbena. ti return 0 in that case.
    #     return 0
    # if root.left==None and root.right==None:
    #     return root.data
    # #else
    # return sum_of_leaves(root.left,sum) + sum_of_leaves(root.right,sum)

# Building the tree manually (same as before)
root = Node(30)
root.left = Node(10)
root.right = Node(40)
root.left.left = Node(3)
root.left.right = Node(15)
root.left.left.left = Node(2)
root.right.left = Node(35)
root.right.right = Node(55)
root.right.left.right = Node(36)

# DRIVER CODE
print(sum_of_leaves(root, 0))

#binary tree sum of leaf nodes
class Node:
    def __init__(self, key):
        self.data = key
        self.left = None
        self.right = None
    #     1
    #    / \
    #   2   3
    #  / \
    # 4   5

def sum_of_leaves(root,sum):
    if root==None:#base case.....leaf node er porer node None.. so setar jnno to kisu sum e add hbena. ti return 0 in that case.
        return 0
    if root.left==None and root.right==None:
        return root.data
    #else
    return sum_of_leaves(root.left,sum) + sum_of_leaves(root.right,sum)
    # sum+=sum_of_leaves(root.left,sum)
    # sum+=sum_of_leaves(root.right,sum)
    # return sum

# Build the binary tree
root = Node(1)
root.left = Node(2)
root.right = Node(3)
root.left.left = Node(4)
root.left.right = Node(5)

# DRIVER CODE
print("Sum of all leaf nodes:", sum_of_leaves(root,0))

#ttoal sum of total nodes
class Node:
    def __init__(self, key):
        self.data = key
        self.left = None
        self.right = None
    #     1
    #    / \
    #   2   3
    #  / \
    # 4   5
def sum_of_leaves(root,sum):
    if root==None:
        return sum
    sum+=root.data
    sum=sum_of_leaves(root.left,sum)
    sum=sum_of_leaves(root.right,sum)
    return sum
# Build the binary tree
root = Node(1)
root.left = Node(2)
root.right = Node(3)
root.left.left = Node(4)
root.left.right = Node(5)

# DRIVER CODE
print("Sum of all leaf nodes:", sum_of_leaves(root,0))

#task4
class BTNode:
    def __init__(self, elem):
        self.elem = elem
        self.left = None
        self.right = None
def mirror_sum(root):
    if root is None:
        return 0
    def helper_func(x, y):
        if x==None or y==None:
            return 0
        return (x.elem + y.elem) + helper_func(x.left, y.right) + helper_func(x.right, y.left)
    return helper_func(root.left, root.right)
# ------------------ Driver Code ------------------
print("---------------------Test#1---------------------")
# Example Tree 1
root = BTNode(10)
n1 = BTNode(6)
n2 = BTNode(15)
n3 = BTNode(3)
n4 = BTNode(8)
n5 = BTNode(12)
n6 = BTNode(20)

root.left = n1
root.right = n2

n1.left = n3
n1.right = n4

n2.left = n5
n2.right = n6

print("Expected Output: 64")
print("Your output     :", mirror_sum(root))

print("---------------------Test#2---------------------")
# Example Tree 2
root = BTNode(20)
n1 = BTNode(15)
n2 = BTNode(25)
n3 = BTNode(10)
n4 = BTNode(18)
n5 = BTNode(5)
n6 = BTNode(30)

root.left = n1
root.right = n2

n1.left = n3
n1.right = n4

n3.left = n5
n2.right = n6

print("Expected Output: 80")
print("Your output     :", mirror_sum(root))

#task4
class BTNode:
    def __init__(self, elem):
        self.elem = elem
        self.left = None
        self.right = None
def mirror_sum(root):
    if root==None:
        return 0
    def helper(l, r):
        if l==None or r==None:
            return 0
        else:
            sum = l.elem + r.elem
            sum += helper(l.left, r.right)
            sum += helper(l.right, r.left)
            return sum
    return helper(root.left, root.right)
# ------------------ Driver Code ------------------
print("---------------------Test#1---------------------")
root = BTNode(10)
n1 = BTNode(6)
n2 = BTNode(15)
n3 = BTNode(3)
n4 = BTNode(8)
n5 = BTNode(12)
n6 = BTNode(20)

root.left = n1
root.right = n2

n1.left = n3
n1.right = n4

n2.left = n5
n2.right = n6

print("Expected Output: 64")
print("Your output     :", mirror_sum(root))

print("---------------------Test#2---------------------")
root = BTNode(20)
n1 = BTNode(15)
n2 = BTNode(25)
n3 = BTNode(10)
n4 = BTNode(18)
n5 = BTNode(5)
n6 = BTNode(30)

root.left = n1
root.right = n2

n1.left = n3
n1.right = n4

n3.left = n5
n2.right = n6

print("Expected Output: 80")
print("Your output     :", mirror_sum(root))