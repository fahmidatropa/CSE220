# -*- coding: utf-8 -*-
"""cse220 hashing,stack,queue

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lqCzNAhivT6qbiUHnk5sFUN-0XaJ5vF8

# Helper Methods [MUST RUN]
[NO NEED TO SUBMIT]
"""

# You must run this cell to install dependency
! pip3 install fhm-unittest
! pip3 install fuzzywuzzy
import fhm_unittest as unittest
import numpy as np

"""#### Queue Helper Codes [Must Run but MUST NOT Modify]

There is a `Node` class and a `LinkedListQueue` class below.

These classes are needed to solve the Queue based Task.

Just run those cells but don't modify them.
"""

# YOU MUST RUN THIS CELL
# BUT DO NOT modify the CODE in this cell
class Node:
  def __init__(self,elem=None,next=None):
    self.elem = elem
    self.next = next

# YOU MUST RUN THIS CELL
# BUT DO NOT modify the CODE in this cell
class LinkedListQueue:
    def __init__(self):
        self.front = self.rear = None

    def enqueue(self, elem):
        new_node = Node(elem)
        if self.rear is None:
            self.front = self.rear = new_node
            return
        self.rear.next = new_node
        self.rear = new_node

    def dequeue(self):
        if self.is_empty():
            raise RuntimeError("Queue is empty")
        removed_elem = self.front.elem
        self.front = self.front.next
        if self.front is None:
            self.rear = None
        return removed_elem

    def peek(self):
        if self.is_empty():
            raise RuntimeError("Queue is empty")
        return self.front.elem

    def is_empty(self):
        return self.front is None

    def display_queue(self):
        print("Queue (front to rear):", end=" ")
        current = self.front
        while current:
            print(f"{current.elem} ->", end=" ")
            current = current.next
        print("NULL")

"""#### Stack Helper Codes [Must Run but MUST NOT Modify]

`Linked List based Stack is implemented in the following cell.`
"""

class Stack:
  def __init__(self):
    self.__top = None
  def push(self,elem):
    nn = Node(elem,self.__top)
    self.__top = nn
  def pop(self):
    if self.__top == None:
      #print('Stack Underflow')
      return None
    e = self.__top
    self.__top = self.__top.next
    return e.elem
  def peek(self):
    if self.__top == None:
      #print('Stack Underflow')
      return None
    return self.__top.elem
  def isEmpty(self):
    return self.__top == None

"""You can print your stack using the `print_stack()` function below"""

# YOU MUST RUN THIS CELL
# BUT DO NOT modify the CODE in this cell
def print_stack(st):
  if st.isEmpty():
    return
  p = st.pop()
  print('|',p,end=' ')
  if p<10:
    print(' |')
  else:
    print('|')
  #print('------')
  print_stack(st)
  st.push(p)

#optional
#You can run this driver code cell to understand the methods of Stack class
# st = Stack()
# st.push(4)
# st.push(3)
# st.push(5)
# st.push(1)
# st.push(9)

# print('Peeked Element: ',st.peek())
# print('Popped Element: ',st.pop())
# print('Popped Element: ',st.pop())
# print('Popped Element: ',st.pop())
# print('Peeked Element: ',st.peek())
# print('Popped Element: ',st.pop())
# print('Popped Element: ',st.pop())
# print('Peeked Element: ',st.peek())
# print('Popped Element: ',st.pop())
# print(st.isEmpty())

# st = Stack()
# st.push(4)
# st.push(3)
# st.push(5)
# st.push(1)
# st.push(9)
# print_stack(st)
# print('------')

"""# Lab Tasks
[NO NEED TO SUBMIT]

### Lab Task 1 [Hashtable Insertion with Forward Chaining]

Complete the following methods:

`__hash_function()`

`insert()`
"""

class Node:
  def __init__(self, elem=None, next = None):
    self.elem = elem
    self.next = next
class HashTable:#hash tble tai array
  def __init__(self, length):
    n = Node()
    self.ht = [None] * length
    self.length = length
  def show(self):
    count = 0
    for i in self.ht:
      temp = i
      print(count, end=" ")
      while temp!=None:
        print (temp.elem, end="-->")
        temp = temp.next
      count += 1
      print()
  # def __hash_function(self, key):
  #   sum=0
  #   if len(key)%2==0:
  #     for i in range(len(key)):
  #       if i%2==0:
  #         sum+=ord(key[i])
  #   else:
  #     for i in range(len(key)):
  #       if i%2!=0:
  #         sum+=ord(key[i])
  #   return sum%len(self.ht)
  # def insert(self, key, value):
  #   node=Node((key,value))
  #   idx=self.__hash_function(key)
  #   if  self.ht[idx]==None:
  #      self.ht[idx]=node
  #      return
  #   else:
  #     head= self.ht[idx]
  #     temp=head
  #     while temp!=None:
  #       if temp.elem[0]==key:
  #         #########temp.elem[1] = value  # ❌ Tuples are immutable
  #         temp.elem=(key,value)
  #         return
  #       temp=temp.next
  #     temp=head
  #     pre=None
  #     while temp!=None:
  #       if temp.elem[1]<=value:
  #         if head==temp:
  #           node.next=head
  #           #head=node
  #           self.ht[idx]=node
  #         else:
  #           node.next=temp
  #           pre.next=node
  #         return
  #       pre=temp
  #       temp=temp.next
  #     pre.next = node
  def __hash_function(self, key):
    sum=0
    if len(key)%2==0:
      for i in range(len(key)):
        if i%2==0:
          sum+=ord(key[i])
    else:
      for i in range(len(key)):
        if i%2!=0:
          sum+=ord(key[i])
    return sum%len(self.ht)
  def insert(self, key, value):
     idx=self.__hash_function(key)
     node=Node((key,value))
     if self.ht[idx]==None:
       self.ht[idx]=node
     else:
      head=self.ht[idx]
      temp=head
      pre=None
      while temp!=None:
        if temp.elem[0]==key:
          temp.elem=(key,value)
          return
        elif temp.elem[1]<=value:
          if temp==head:
            node.next=head
            self.ht[idx]=node
          else:
            node.next=temp
            pre.next=node
          return
        pre=temp
        temp=temp.next
      pre.next=node#pre te last node save ase. nd temp=None hoe gese
      #value oi idx er ekta value thekeo boro na tokhon last e e add hbe

#Driver Code
ht = HashTable(3)
ht.insert("apple", 20)
ht.insert("coconut", 90)
ht.insert("cherry", 50)
ht.show()
print("------------")
ht.insert("banana", 30)
ht.insert("pineapple", 50)
ht.show()
print("------------")
ht.insert("apple", 100)
ht.insert("guava", 10)
ht.show()
# Driver Code Output:
# 0 ('coconut', 90)-->
# 1 ('apple', 20)-->
# 2 ('cherry', 50)-->
# ------------
# 0 ('coconut', 90)-->('pineapple', 50)-->('banana', 30)-->
# 1 ('apple', 20)-->
# 2 ('cherry', 50)-->
# ------------
# 0 ('coconut', 90)-->('pineapple', 50)-->('banana', 30)-->
# 1 ('apple', 100)-->('guava', 10) -->
# 2 ('cherry', 50)-->

"""### Lab Task 2 [Stack: Tower of Blocks]"""

def remove_block(stack, n):
 #TO DO
 s=Stack()
 top=1
 while st.isEmpty()==False:
  if top==n:
    st.pop()
  else:
   s.push(st.pop())
  top+=1
 while s.isEmpty()==False:
    st.push(s.pop())

print('Test 01')
st = Stack()
st.push(4)
st.push(19)
st.push(23)
st.push(17)
st.push(5)
print('Given Stack:')
print_stack(st)
print('------')
print('Value of N = 2')
remove_block(st,2)
print('\nAfter Removal')
print_stack(st)
print('------')
print()
print('======================================')
print()
print('Test 02')
st = Stack()
st.push(73)
st.push(85)
st.push(15)
st.push(41)
print('Given Stack:')
print_stack(st)
print('------')
print('Value of N = 3')
remove_block(st,3)
print('\nAfter Removal')
print_stack(st)
print('------')

print()
print('======================================')
print()

"""### Lab Task 3 [Queue: Customer Service Call Center]

`Hint: You need to utilize the objects of LinkedListQueue class for this task`
"""

class CallQueue:
    def __init__(self):
        self.vip_queue = LinkedListQueue()
        self.regular_queue = LinkedListQueue()

    def enqueue_call(self, customer_id, is_vip):
        #To Do
        pass#delete this line when you're done

    def dequeue_call(self):
        # To Do
        pass#delete this line when you're done

    def display_queue(self):
        # To Do
        pass#delete this line when you're done

"""Driver/Tester codes"""

# YOU MUST RUN THIS CELL TO TEST YOUR CODE
# If you modify the method calls the outputs will be changed as well
call_center = CallQueue()
# Enqueueing customers
call_center.enqueue_call(101, False)  # Regular customer
call_center.enqueue_call(201, True)   # VIP customer
call_center.enqueue_call(102, False)  # Regular customer
call_center.enqueue_call(202, True)   # VIP customer
call_center.enqueue_call(103, False)  # Regular customer

call_center.display_queue()

# Processing calls
call_center.dequeue_call()
call_center.dequeue_call()
call_center.dequeue_call()
call_center.dequeue_call()
call_center.dequeue_call()
call_center.dequeue_call()  # No more calls

call_center.display_queue()

#   ::Expected Ouput::

# Customer 101 added to Regular queue.
# Customer 201 added to VIP queue.
# Customer 102 added to Regular queue.
# Customer 202 added to VIP queue.
# Customer 103 added to Regular queue.

# VIP Queue:
# Queue (front to rear): 201 -> 202 -> NULL
# Regular Queue:
# Queue (front to rear): 101 -> 102 -> 103 -> NULL

# Processing VIP Customer 201.
# Processing VIP Customer 202.
# Processing Regular Customer 101.
# Processing Regular Customer 102.
# Processing Regular Customer 103.
# No calls in the queue.

# VIP Queue:
# Queue (front to rear): NULL
# Regular Queue:
# Queue (front to rear): NULL

"""# Assignment Tasks
**[MUST SUBMIT]**

### **Assignment Task 1** [ HashTable : Deletion from Hashtable ]

Complete the following methods and submit them:

`__hash_function()`

`remove()`
"""

class Node_pair:
  def __init__(self, key, value, next = None):
    self.key, self.value, self.next = key, value, next


class Hashtable:

  #NO NEED TO SUBMIT
  def __init__(self, size):
    self.ht = [None]*size

  #NO NEED TO SUBMIT
  def insert(self, s):
    hashed_index = self.__hash_function(s[0])
    pair = Node_pair(s[0], s[1])
    if self.ht[hashed_index] == None:
      self.ht[hashed_index] = pair
    else:
      pair.next = self.ht[hashed_index]
      self.ht[hashed_index] = pair

  #NO NEED TO SUBMIT
  def create_from_array(self, arr):
    for i in arr:
      self.insert(i)

  #NO NEED TO SUBMIT
  def print_hashtable(self):
    idx = 0
    for i in self.ht:
      print(idx, ':', end = ' ')
      head = i
      while head != None:
        print(f'({head.key}, {head.value})', end = '-->')
        head = head.next
      print('None')
      idx += 1

  #Do it by yourself
  #MUST SUBMIT
  def __hash_function(self, key):
    #TO DO
    return (key+3)%len(self.ht)
  def remove(self, key):
    #TO DO
    idx=self.__hash_function(key)
    head=self.ht[idx]
    temp=head
    pre=None
    while temp!=None:
      if temp.key==key:
        if temp==head:
          self.ht[idx]=temp.next
        else:
          pre.next=temp.next
        return
      pre=temp
      temp=temp.next
    return

#Driver Code
#NO NEED TO SUBMIT
#JUST RUN and TEST
arr=[(34, 'Abid') , (4, 'Rafi'), (6, 'Karim'), (3, 'Chitra'), (22, 'Nilu')]
ht = Hashtable(6)
ht.create_from_array(arr)
ht.print_hashtable()

#This should print

#0: (3, “Chitra”) --> None
#1: (22, “Nilu”) --> (4, “Rafi”) --> (34, “Abid”) --> None
#2: None
#3: (6, “Karim”) --> None
#4: None
#5: None

print('======================')

ht.remove(9)
ht.print_hashtable()
#This should print

#0: (3, “Chitra”) --> None
#1: (22, “Nilu”) --> (4, “Rafi”) --> (34, “Abid”) --> None
#2: None
#3: (6, “Karim”) --> None
#4: None
#5: None

print('======================')

ht.remove(4)
ht.print_hashtable()
#This should print

#0: (3, “Chitra”) --> None
#1: (22, “Nilu”) --> (34, “Abid”) --> None
#2: None
#3: (6, “Karim”) --> None
#4: None
#5: None

"""### **Assignment Task 2** [ Stack : Diamond Count ]"""

def diamond_count(stack,string):
  # c=0
  # for i in string:
  #   if i=='<':
  #     stack.push(i)
  #   elif i=='>':
  #     #if stack.peek()=='<':
  #     if stack.isEmpty()==False:
  #      stack.pop()
  #      c+=1
  # return c
  c=0
  for i in string:
    if i=='<':
      stack.push(i)
    elif i=='>':
     if stack.peek()=='<':
       stack.pop()
       c+=1

  return c
print('Test 01')
stack = Stack()
string = '<..><.<..>> '
returned_value = diamond_count(stack,string)
print(f'Number of Diamonds: {returned_value}') #This should print 3
unittest.output_test(returned_value, 3)
print('-----------------------------------------')


print('Test 02')
stack = Stack()
string = '<<<..<......<<<<....>'
returned_value = diamond_count(stack,string)
print(f'Number of Diamonds: {returned_value}') #This should print 1
unittest.output_test(returned_value, 1)
print('-----------------------------------------')


print('Test 03')
stack = Stack()
string = '>>><...<<..>>...>...>>>'
returned_value = diamond_count(stack,string)
print(f'Number of Diamonds: {returned_value}') #This should print 3
unittest.output_test(returned_value, 3)
print('-----------------------------------------')

"""### Assignment Task 3 [Queue : Remove Consecutive Duplicates]"""

def removeConsecutiveDups( word ): #enqueue. dequeue is_empty
    q=LinkedListQueue()
    # last=''
    # for i in word:
    #   if q.is_empty()==True:
    #     q.enqueue(i)
    #     last=i
    #   else:
    #     if last==i:
    #       continue
    #     else:
    #       q.enqueue(i)
    #       last=i
    # w=''
    # while q.is_empty()==False:
    #   w+=q.dequeue()
    # return w
    w=''
    for i in word:
      if q.is_empty()==True:
        q.enqueue(i)
      else:
        if q.peek()==i:
          continue
        else:
          q.enqueue(i)
    while q.is_empty()==False:
     w+=q.dequeue()
    return w
print('Test 01')
string = 'aabbbccccdd'
returned_value = removeConsecutiveDups(string)
unittest.output_test(returned_value, 'abcd')
print('-----------------------------------------')


print('Test 02')
string = 'aaabbaa'
returned_value = removeConsecutiveDups(string)
unittest.output_test(returned_value, 'aba')
print('-----------------------------------------')


print('Test 03')
string = 'abcabcabc'
returned_value = removeConsecutiveDups(string)
unittest.output_test(returned_value, 'abcabcabc')
print('-----------------------------------------')

print('Test 04')
string = 'aaaaa'
returned_value = removeConsecutiveDups(string)
unittest.output_test(returned_value, 'a')
print('-----------------------------------------')

"""# Ungraded Tasks
[NO NEED TO SUBMIT]

### Ungraded Task 1 [Searching in Hashtable]

Complete the following methods:

`__hash_function()`

`search_hashtable()`
"""

class Node_pair:
  def __init__(self, key, value, next = None):
    self.key, self.value, self.next = key, value, next
class Hashtable:
  def __init__(self, size):
    self.ht = [None]*size
  def insert(self, s):
    if self.search_hashtable(s) == 'Found':
      print(s,'Already Inserted. Cannot reinsert.')
      print('===============================')
      return
    hashed_index = self.__hash_function(s[0])
    pair = Node_pair(s[0], s[1])
    if self.ht[hashed_index] == None:
      self.ht[hashed_index] = pair
    else:
      pair.next = self.ht[hashed_index]
      self.ht[hashed_index] = pair
  def create_from_array(self, arr):
    for i in arr:
      self.insert(i)
  def print_hashtable(self):
    idx = 0
    for i in self.ht:
      print(idx, ':', end = ' ')
      head = i
      while head != None:
        print(f'(key: {head.key}, value: {head.value})', end = '-->')
        head = head.next
      print('None')
      print()
      idx += 1
  #Do it by yourself
  def __hash_function(self, key):
    sum=0
    st=''
    if len(key)%2==0:
      for i in range(0,len(key),2):
        st+=str(ord(key[i])+ord(key[i+1]))
        sum+=int(st)
    else:
      key+='N'
      for i in range(0,len(key),2):
        st+=str(ord(key[i])+ord(key[i+1]))
        sum+=int(st)
    return sum%len(self.ht)
  #Do it by yourself
  def search_hashtable(self, s):
    idx=self.__hash_function(s[0])
    head=self.ht[idx]
    temp=head
    while temp!=None:
      if temp.key==s[0]:
        return 'Found'
      temp=temp.next
    return 'Not Found'

#Driver Code
arr = [('Colt', 360), ('Cordelius', 730), ('Shelly', 300), ('Doug', 1200), ('Emz', 520), ('Bo', 580)]
ht = Hashtable(5)
ht.create_from_array(arr)
ht.print_hashtable()
print('======================')
result = ht.search_hashtable(('Doug', 1200))
unittest.output_test(result, 'Found')
print(f'(Doug, 1200) {result}')
print('======================')
ht.insert(('Doug', 1200))
ht.print_hashtable()
print('======================')
result = ht.search_hashtable(('Edgar', 320))
unittest.output_test(result, 'Not Found')
print(f'(Edgar, 320) {result}')
print('======================')
ht.insert(('Edgar', 320))
ht.print_hashtable()
print('======================')
result = ht.search_hashtable(('Edgar', 320))
unittest.output_test(result, 'Found')
print(f'(Edgar, 320) {result}')

"""### Ungraded Task 2 [Stack Reverse]"""

def conditional_reverse(stack):
  s=Stack()
  top=1
  while st.isEmpty()==False:
   if top==1:
    s.push(st.pop())
   elif top!=1:
    if s.peek()==st.peek():
      st.pop()
    else:
      s.push(st.pop())
   top+=1
  return s
print('Test 01')
st=Stack()
st.push(10)
st.push(10)
st.push(20)
st.push(20)
st.push(30)
st.push(10)
st.push(50)
print('Stack:')
print_stack(st)
print('------')
reversed_stack=conditional_reverse(st)
print('Conditional Reversed Stack:')
if reversed_stack==None:
    print("Incomplete Task")
else:
    print_stack(reversed_stack) # This stack contains 50, 10, 30, 20, 10 in this order whereas top element should be 10
print('------')