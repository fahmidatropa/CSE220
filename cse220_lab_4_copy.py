# -*- coding: utf-8 -*-
"""cse220 lab 4 copy

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Ak1ysZnvOT_LZ_t38h-MHZea-Jmjp_bf
"""

# You must run this cell to install dependency
! pip3 install fhm-unittest
! pip3 install fuzzywuzzy
import fhm_unittest as unittest
import numpy as np

"""# **Hashtable**

### **Task-1:** [Searching in Hashtable]

Complete the following methods:

`__hash_function()`

`search_hashtable()`
"""

class Node_pair:
  def __init__(self, key, value, next = None):
    self.key, self.value, self.next = key, value, next


class Hashtable:
  def __init__(self, size):
    self.ht = [None]*size


  def insert(self, s):
    if self.search_hashtable(s) == 'Found':
      print(s,'Already Inserted. Cannot reinsert.')
      print('===============================')
      return
    hashed_index = self.__hash_function(s[0])
    pair = Node_pair(s[0], s[1])
    if self.ht[hashed_index] == None:
      self.ht[hashed_index] = pair
    else:
      pair.next = self.ht[hashed_index]
      self.ht[hashed_index] = pair
  def create_from_array(self, arr):
    for i in arr:
      self.insert(i)
  def print_hashtable(self):
    idx = 0
    for i in self.ht:
      print(idx, ':', end = ' ')
      head = i
      while head != None:
        print(f'(key: {head.key}, value: {head.value})', end = '-->')
        head = head.next
      print('None')
      print()
      idx += 1
  #Do it by yourself
  def __hash_function(self, key):#hashfunction e sudhu key jabe parameter hisebe. value na
    #TO DO
    con=''
    idx=0
    if len(key)%2==0:
      for i in range(0,len(key),2):
        con=str(ord(key[i]))#ord(key[i])=type int. so str e kisu add krte gele setak str e convert krte hoy.. ti str e convert kra hoise
        con+=str(ord(key[i+1]))
        idx+=int(con)
    else:
      key+='N'
      for i in range(0,len(key),2):
        con+=str(ord(key[i]))
        con+=str(ord(key[i+1]))
        idx+=int(con)
    return idx%len(self.ht)
  #Do it by yourself
  def search_hashtable(self, s):#s=tuple=('Doug', 1200)
    idx=self.__hash_function(s[0])#s[0]='Drug'..idx=hashtable(ht) er jei idx e s tuple(('Doug', 1200)) bosbe as a node..hashfunc e parameter hisebe sudhu key jabe
    key,value=s
    head=self.ht[idx]#s hashtable er jei idx e thakar ktha seta holo idx. sei idx e ek/ekadhik/None node thakte pare. so jdi node thake tile tar head node address=self.ht[idx]
    #ht table er idx e node jdi thake/na thake node setak head dhortesi. jdi idx e node thake tobe head=oi node er address(1 tar besi node thkle,1st node er address holo head)
    #oi idx e node thakle head!=None. node na thakle oi idx e head=None
    #hashtable(ht) er idx e node e thakbe element hisebe
    ###############search fun so node creat krbona. node khujbo##############
    temp=head
    while temp!=None:#jdi oi ht er oi idx e node thake tobe temp/head!=None
      if temp.key==key and temp.value==value:#node oi idx e thakle dn chq krbo key,value mile kine oi node er. mille found.
      # Node cls e def __init__(self, key, value, next = None) eta ase so means key,value tuple hisebe nibena node element e. ti key value alada vabe chq kra hoche
        return 'Found'
      temp=temp.next
    return 'Not Found'#else condition. temp==None. means ht er oi idx e node na thakle not found return krbe. cz node e nei kono oi idx e so found o psbl na.
    #abar jdi temp!=None hoy bt key pair match krena tileo not found return krbe

#Driver Code
arr = [('Colt', 360), ('Cordelius', 730), ('Shelly', 300), ('Doug', 1200), ('Emz', 520), ('Bo', 580)]
ht = Hashtable(5)
ht.create_from_array(arr)
ht.print_hashtable()
print('======================')
result = ht.search_hashtable(('Doug', 1200))
unittest.output_test(result, 'Found')
print(f'(Doug, 1200) {result}')

print('======================')
ht.insert(('Doug', 1200))
ht.print_hashtable()

print('======================')
result = ht.search_hashtable(('Edgar', 320))
unittest.output_test(result, 'Not Found')
print(f'(Edgar, 320) {result}')

print('======================')
ht.insert(('Edgar', 320))
ht.print_hashtable()

print('======================')
result = ht.search_hashtable(('Edgar', 320))
unittest.output_test(result, 'Found')
print(f'(Edgar, 320) {result}')

"""### **Task-2:** [Hashtable with Forward Chaining]

Complete the following methods:

`__hash_function()`

`insert()`
"""

class Node:
  def __init__(self, value=None, next = None):#value=node ht table e
    self.value = value
    self.next = next
class HashTable:
  def __init__(self, length):
    n = Node()#value pass krini
    self.ht = [n] * length######n=node, [node, node, node....] ei hastable e ek ekta node ase
#so prottek node e value None.. ht table e n.value=None initially
    self.length = length

  def show(self):
    count = 0
    for i in self.ht:
      temp = i
      print(count, end=" ")
      while temp!=None:
        print (temp.value, end="-->")
        temp = temp.next
      count += 1
      print()
  #Do it by yourself
  def __hash_function(self, key):
    #TO DO
    idx=0
    if len(key)%2==0:
      for i in range (len(key)):
        if i%2==0:
          idx+=ord(key[i])
    else:
      for i in range (len(key)):
        if i%2!=0:
          idx+=ord(key[i])
    return idx%len(self.ht)
  #Do it by yourself
  def insert(self, key, value):#value=3
    #TO DO
    idx=self.__hash_function(key)
    node=Node((key,value))#value=(key,value).. Node cls e value=(key,value)
    #if self.ht[idx]==None:#eta hbena. cz node ase. ti none psbl na.
    if self.ht[idx]==None:#ht table er oi idx e jdi kono node na thake tile
      self.ht[idx]=node#new node oi idx e bose jabe
    else:#age theke oi idx e single node/link list thakle
      head=self.ht[idx]
      temp=head
      prev=None
      if temp.value[1]<node.value[1]:#if temp.value<value... def insert(self, key, 10).. node.value/value=10
        node.next=temp#new node head hoe galo.... 10-->6-->4-->2
        self.ht[idx]=node#new head means node k oi idx e bosailam ht table er
        return #ei if cndtn kaaj na krle return e dhukbena. ti abar nicher while e dhukbe. r e return e dhukle insert func theke ber hoe jaito
      while temp!=None:#tail e insert...6-->4-->2--1... here value is 1. nd this 1 will be in the tail of the linklist
        if temp.value[1]>node.value[1] and temp.next==None:#(temp.value)2>1(node.value)
          temp.next=node#here temp=2.. this is the last node of ll. temp.next=node(means node 1.. value=1 )
          return
      else:#middle e insert.. not in head or tail
       while temp!=None:#6-->4-->2...insert(key,3).new ll will be 6-->4-->3-->2.
        if temp.value[1]<node.value[1]:# if temp.value[1]<value:... value=3. so insert hbe middle e
          #if condition e dhukbe jkhn temp.value=2.... cz 2<3
          prev.next=node#prev=4.. prev.next=node(4-->3)....middle e insert hash table er link list e..6-->4-->3-->2
          node.next=temp#node(3), temp(2)...3-->2
          return #insert func theke ber hoe jabe return krate
        prev=temp#4
        temp=temp.next
      prev.next=node

#Driver Code
ht = HashTable(3)
ht.insert("apple", 20)
ht.insert("coconut", 90)
ht.insert("cherry", 50)
ht.show()
print("------------")
ht.insert("banana", 30)
ht.insert("pineapple", 50)
ht.show()
print("------------")
ht.insert("apple", 100)
ht.insert("guava", 10)
ht.show()

# Driver Code Output:
# 0 ('coconut', 90)-->
# 1 ('apple', 20)-->
# 2 ('cherry', 50)-->
# ------------
# 0 ('coconut', 90)-->('pineapple', 50)-->('banana', 30)-->
# 1 ('apple', 20)-->
# 2 ('cherry', 50)-->
# ------------
# 0 ('coconut', 90)-->('pineapple', 50)-->('banana', 30)-->
# 1 ('apple', 100)-->('guava', 10) -->
# 2 ('cherry', 50)-->

"""### **Task-3:** [Deletion from Hashtable]

Complete the following methods:

`__hash_function()`

`remove()`
"""

#task3 submit
class Node_pair:
  def __init__(self, key, value, next = None):
    self.key, self.value, self.next = key, value, next
class Hashtable:
  def __init__(self, size):
    self.ht = [None]*size
  def insert(self, s):
    hashed_index = self.__hash_function(s[0])
    pair = Node_pair(s[0], s[1])
    if self.ht[hashed_index] == None:
      self.ht[hashed_index] = pair
    else:
      pair.next = self.ht[hashed_index]
      self.ht[hashed_index] = pair
  def create_from_array(self, arr):
    for i in arr:
      self.insert(i)
  def print_hashtable(self):
    idx = 0
    for i in self.ht:
      print(idx, ':', end = ' ')
      head = i
      while head != None:
        print(f'({head.key}, {head.value})', end = '-->')
        head = head.next
      print('None')
      idx += 1
  #Do it by yourself
  def __hash_function(self, key):
    #TO DO
    return (key+3)%len(self.ht)
  #Do it by yourself
  def remove(self, key):
    #TO DO
    idx=self.__hash_function(key)
    head=self.ht[idx]
    temp=head
    if head.key==key:#when key matches the head node. exmplt remove(22).. here 22 is the head node key
      #self.ht[idx] = temp.next
      head=head.next
      #self.ht[idx]=head xxxxxxxxxxxxx cz its only modifies the local variable. doesnt make chng in the indext of hashtable
      self.ht[idx]=head#r9ght way to write is this
    else:
      while temp!=None:
        if temp.key==key:
          prev.next=temp.next
        prev=temp
        temp=temp.next

#Driver Code
arr=[(34, 'Abid') , (4, 'Rafi'), (6, 'Karim'), (3, 'Chitra'), (22, 'Nilu')]
ht = Hashtable(6)
ht.create_from_array(arr)
ht.print_hashtable()
#This should print
#0: (3, “Chitra”) --> None
#1: (22, “Nilu”) --> (4, “Rafi”) --> (34, “Abid”) --> None
#2: None
#3: (6, “Karim”) --> None
#4: None
#5: None

print('======================')

ht.remove(9)
ht.print_hashtable()
#This should print

#0: (3, “Chitra”) --> None
#1: (22, “Nilu”) --> (4, “Rafi”) --> (34, “Abid”) --> None
#2: None
#3: (6, “Karim”) --> None
#4: None
#5: None

print('======================')
print('======================')

ht.remove(4)
ht.print_hashtable()
#This should print

#0: (3, “Chitra”) --> None
#1: (22, “Nilu”) --> (34, “Abid”) --> None
#2: None
#3: (6, “Karim”) --> None
#4: None
#5: None

"""# **Stack**

### Helper Codes [Must Run but MUST NOT Modify]

`Linked List based Stack is implemented in the following cell.`
"""

# YOU MUST RUN THIS CELL
# BUT DO NOT modify the CODE in this cell
class Node:
  def __init__(self,elem=None,next=None):
    self.elem = elem
    self.next = next
class Stack:#stack = Stack() jokhon stack obj create holo Stack cls er under e
  def __init__(self):#ekhane must dhukbe age
    self.__top = None
  def push(self,elem):
    nn = Node(elem,self.__top)
    self.__top = nn
  def pop(self):#np parameter
    if self.__top == None:
      #print('Stack Underflow')
      return None
    e = self.__top #else
    self.__top = self.__top.next
    return e.elem#oi node er value return krbe. nd top er node dlt krbe. er next ta hbe new top. (head chng)
  def peek(self):
    if self.__top == None:
      #print('Stack Underflow')
      return None
    return self.__top.elem

  def isEmpty(self):
    return self.__top == None#boolean return. array/linked list empty thakle true return krbe. ar empty na thakle. mean self.__top != None hole False return krbe

#optional
#You can run this driver code cell to understand the methods of Stack class
st = Stack()
st.push(4)
st.push(3)
st.push(5)
st.push(1)
st.push(9)

print('Peeked Element: ',st.peek())
print('Popped Element: ',st.pop())
print('Popped Element: ',st.pop())
print('Popped Element: ',st.pop())
print('Peeked Element: ',st.peek())
print('Popped Element: ',st.pop())
print('Popped Element: ',st.pop())
print('Peeked Element: ',st.peek())
print('Popped Element: ',st.pop())
print(st.isEmpty())

"""You can print your stack using the `print_stack()` function below"""

# YOU MUST RUN THIS CELL
# BUT DO NOT modify the CODE in this cell
def print_stack(st):
  if st.isEmpty():
    return
  p = st.pop()#else
  print('|',p,end=' ')
  if p<10:
    print(' |')
  else:
    print('|')
  #print('------')
  print_stack(st)
  st.push(p)

# st = Stack()
# st.push(4)
# st.push(3)
# st.push(5)
# st.push(1)
# st.push(9)
# print_stack(st)
# print('------')

"""### **Task-4:** [Diamond Count]"""

#task3
def diamond_count(stack,string):
  #TO DO
 c=0
 for i in string:
   if i=='<':
    stack.push(i)#stack object.. etar jnno Stack cls e jache first e init e. dn push method e. push method er elem=i
   elif i=='>' and stack.peek()=='<': #stack.peek=top e jei element ase seta==<
    stack.pop()
    c+=1
 return c
print('Test 01')
stack = Stack()
string = '<..><.<..>> '
returned_value = diamond_count(stack,string)
print(f'Number of Diamonds: {returned_value}') #This should print 3
unittest.output_test(returned_value, 3)
print('-----------------------------------------')
print('Test 02')
stack = Stack()
string = '<<<..<......<<<<....>'
returned_value = diamond_count(stack,string)
print(f'Number of Diamonds: {returned_value}') #This should print 1
unittest.output_test(returned_value, 1)
print('-----------------------------------------')
print('Test 03')
stack = Stack()
string = '>>><...<<..>>...>...>>>'
returned_value = diamond_count(stack,string)
print(f'Number of Diamonds: {returned_value}') #This should print 3
unittest.output_test(returned_value, 3)
print('-----------------------------------------')

"""### **Task-5:** [Tower of Blocks]"""

def remove_block(stack, n):##########khata###########
  #TO DO
  #stack er majkhan die element rmv kra jayna(sudhu top e element rmv or add psbl) ti new stack nie ei task krte hbe
 stack2=Stack()#temporary/new stack creating
 top=1#def isEmpty(self):
 while stack.isEmpty()==False:#st stack ta jotohon na empty hbe totokhon new stack(stack) e push continue hbe
    if top==n:
      stack.pop()#17 rmv holo st theke
    else:#1st e else e dhukbe
      stack2.push(stack.pop())#stack.push(5)..st.pop()=5(top element)
    top+=1
 while stack2.isEmpty()==False:#again new stack empty na hoa porjont
  stack.push(stack2.pop())#old stack(st) te push krtesi new stack pop krar madhome
  #1st iteration-->st.push(4)....(stack(pop)=4)
  #st.push() krsi cz 28 nmbr line onujai st stack tai print hbe. amra jei new stack(stack) dhorsi oita print hbena
print('Test 01')
st = Stack()
st.push(4)
st.push(19)
st.push(23)
st.push(17)
st.push(5)
print('Stack:')
print_stack(st)#st er element print krbe.
print('------')
remove_block(st,2)#st holo stack. jekahne 4,19,23,17,5 eleemtn ase. top e ase 5
print('After Removal')
print_stack(st)#5,23,19,4 print hbe.jekahne n=2 means 17 ni. top e ase ekhane still 5
print('------')
print()
print('======================================')
print()
print('Test 02')
st = Stack()
st.push(73)
st.push(85)
st.push(15)
st.push(41)
print('Stack:')
print_stack(st)
print('------')
remove_block(st,3)
print('After Removal')
print_stack(st)
print('------')
print()
print('======================================')
print()

"""### **Task-6:** [Stack Reverse]"""

#task6 without revesing. only rmving consecutive elements
def conditional_reverse(stack):#st=Stack. so i need to write stack.pop.. stack.isEmpty....................
#not st.isEmpty.. st.pop()... cz st is passed in parameter as stack. so before it was st b under conditional_reverse func()its now stack
  #To Do
  stack2=Stack()#new stack create
  while stack.isEmpty()==False:
    #if stack.peek()==stack2.peek(): xxxxxx cz for 1st iteration. stack2 is empty..so stack.peek()=50.. nd stack2.peek()=error. cz stack2 empty for 1st iteration. so
    #this if condition will give error
    if stack2.isEmpty()==False and stack.peek() == stack2.peek():#stack2.isEmpty()==False means stack2 is not empty
      stack.pop()#old stack theke repeated eleemnt rmv krbo
      continue
    else:
      stack2.push(stack.pop())
  while stack2.isEmpty()==False:#14,15 line drkr ni.. cz eta reverse krte blse. r ei line duita die amra abr ager formate e stack ani. bt ekhane reverse jehetu blse so ei dui line drkr ni
   stack.push(stack2.pop())
  return stack#reversed output return krtesena
print('Test 01')
st=Stack()
st.push(10)
st.push(10)
st.push(20)
st.push(20)
st.push(30)
st.push(10)
st.push(50)
print('Stack:')
print_stack(st)
print('------')
reversed_stack=conditional_reverse(st)
print('Conditional Reversed Stack:')
if reversed_stack==None:
    print("Incomplete Task")
else:
    print_stack(reversed_stack) # This stack contains 50, 10, 30, 20, 10 in this order whereas top element should be 10
print('------')

#task6
def conditional_reverse(stack):#st=Stack. so i need to write stack.pop.. stack.isEmpty....................
#not st.isEmpty.. st.pop()... cz st is passed in parameter as stack. so before it was st b under conditional_reverse func()its now stack
  #To Do
  stack2=Stack()#new stack create
  while stack.isEmpty()==False:
    #if stack.peek()==stack2.peek(): xxxxxx cz for 1st iteration. stack2 is empty..so stack.peek()=50.. nd stack2.peek()=error. cz stack2 empty for 1st iteration. so
    #this if condition will give error
    if stack2.isEmpty()==False and stack.peek() == stack2.peek():#stack2.isEmpty()==False means stack2 is not empty
      stack.pop()#old stack theke repeated eleemnt rmv krbo
      continue
    else:
      stack2.push(stack.pop())
  print(stack2.peek())
  return stack2
print('Test 01')
st=Stack()
st.push(10)
st.push(10)
st.push(20)
st.push(20)
st.push(30)
st.push(10)
st.push(50)
print('Stack:')
print_stack(st)
print('------')
reversed_stack=conditional_reverse(st)
print('Conditional Reversed Stack:')
if reversed_stack==None:
    print("Incomplete Task")
else:
    print_stack(reversed_stack) # This stack contains 50, 10, 30, 20, 10 in this order whereas top element should be 10
print('------')

#task #######gpt#######
def conditional_reverse(stack):
    stack2 = Stack()  # Create a new stack

    prev = None  # Track the previous element
    while not stack.isEmpty():
        top_element = stack.pop()
        if top_element == prev:
            continue  # Skip consecutive duplicate elements
        stack2.push(top_element)
        prev = top_element
    return stack2#reveersed stack return to 29 line. where the eleements will print
print('Test 01')
st=Stack()
st.push(10)
st.push(10)
st.push(20)
st.push(20)
st.push(30)
st.push(10)
st.push(50)
print('Stack:')
print_stack(st)
print('------')
reversed_stack=conditional_reverse(st)
print('Conditional Reversed Stack:')
if reversed_stack==None:
    print("Incomplete Task")
else:
    print_stack(reversed_stack) # This stack contains 50, 10, 30, 20, 10 in this order whereas top element should be 10
    #nd this 29 line is printing the expected ouput which is reversd stack and without consecutive
print('------')

"""# Queue

### Helper Codes [Must Run but MUST NOT Modify]

There is a `Node` class and a `LinkedListQueue` class below.

These classes are needed to solve the Queue based Task.

Just run those cells but don't modify them.
"""

# YOU MUST RUN THIS CELL
# BUT DO NOT modify the CODE in this cell
class Node:
    def __init__(self, elem):
        self.elem = elem
        self.next = None

# YOU MUST RUN THIS CELL
# BUT DO NOT modify the CODE in this cell
class LinkedListQueue:
    def __init__(self):
        self.front = self.rear = None #node nei, linked list nei. jkhnn f,r=None

    def enqueue(self, elem):
        new_node = Node(elem)
        if self.rear is None:#no node, no link list
            self.front = self.rear = new_node
            return
        self.rear.next = new_node
        self.rear = new_node

    def dequeue(self):
        if self.is_empty():
            raise RuntimeError("Queue is empty")
        removed_elem = self.front.elem
        self.front = self.front.next
        if self.front is None:
            self.rear = None
        return removed_elem #dequeue te j node remove krbo tar elem return krbe

    def peek(self):
        if self.is_empty():
            raise RuntimeError("Queue is empty")
        return self.front.elem

    def is_empty(self):
        return self.front is None

    def display_queue(self):
        print("Queue (front to rear):", end=" ")
        current = self.front
        while current:
            print(f"{current.elem} ->", end=" ")
            current = current.next
        print("NULL")

"""### **Task-7:** [Customer Service Call Center]

`Hint: You need to utilize the LinkedListQueue class for this task`
"""

# class CallQueue:
#     def init(self):#2 ta queue create (vip,rglr)
#         self.vip_queue = LinkedListQueue()#vip quque er node/link list
#         self.regular_queue = LinkedListQueue()#rgrlr queue er.....
#     def enqueue_call(self, customer_id, is_vip):
#         #To Do
#         if is_vip:#if true=vip queue. so
#           self.vip_queue.enqueue(customer_id)#so age vip custoer id add hbe
#         else:
#           print(f"Customer {customer_id}  added to Regular queue.")
#           self.regular_queue.enqueue(customer_id)#else=is_vip=False. means rglr customer id ti rgrlr queue te add hbe
#     def dequeue_call(self):
#         # To Do
#         if self.vip_queue.is_empty():#jdi vip queue er link list empty hoy tobei rglr queue theke rmv hbe. r naile vip queue theke dequue/rmv hbe.
#         ##qstn onujai age vip queue er manus dekhabe erpor rgrlr queue er. ti deque hbe age vip. cz dekhabe tara age, priority tader age. jar priority besi se age deque hbe
#           if self.regular_queue.is_empty()!=True:# self.regular_queue.is_empty()==True
#             self.regular_queue.dequeue()#vip queue empty hole nd rglr queue empty na hoy tobei rglr quue theke dequeue hbe
#         else:
#           if self.vip_queue.is_empty()!=True:#vip queue empty na hole age vip qeueu theke dequeue hbe
#             self.vip_queue.dequeue()
#     def display_queue(self):
#         self.vip_queue.display_queue()
#         self.regular_queue.display_queue()

class CallQueue:
    def __init__(self):
        self.vip_queue = LinkedListQueue()
        self.regular_queue = LinkedListQueue()

    def enqueue_call(self, customer_id, is_vip):
      #to do
        if is_vip:
            print(f"Customer {customer_id} added to VIP queue.")
            self.vip_queue.enqueue(customer_id)
        else:
            print(f"Customer {customer_id} added to Regular queue.")
            self.regular_queue.enqueue(customer_id)

    def dequeue_call(self):
      #to do
        if not self.vip_queue.is_empty():  # Process VIP first
            customer_id = self.vip_queue.dequeue()
            print(f"Processing VIP Customer {customer_id}.")
        elif not self.regular_queue.is_empty():  # Process regular if VIP is empty
            customer_id = self.regular_queue.dequeue()
            print(f"Processing Regular Customer {customer_id}.")
        else:
            print("No calls in the queue.")  # No customers left
    def display_queue(self):
      #to do
        print("\nVIP Queue:")
        self.vip_queue.display_queue()
        print("Regular Queue:")
        self.regular_queue.display_queue()

"""Driver/Tester codes"""

# YOU MUST RUN THIS CELL TO TEST YOUR CODE
# If you modify the method calls the outputs will be changed as well
call_center = CallQueue()
# Enqueueing customers
call_center.enqueue_call(101, False)  # Regular customer
call_center.enqueue_call(201, True)   # VIP customer
call_center.enqueue_call(102, False)  # Regular customer
call_center.enqueue_call(202, True)   # VIP customer
call_center.enqueue_call(103, False)  # Regular customer

call_center.display_queue()

# Processing calls
call_center.dequeue_call()
call_center.dequeue_call()
call_center.dequeue_call()
call_center.dequeue_call()
call_center.dequeue_call()
call_center.dequeue_call()  # No more calls

call_center.display_queue()

#   ::Expected Ouput::

# Customer 101 added to Regular queue.
# Customer 201 added to VIP queue.
# Customer 102 added to Regular queue.
# Customer 202 added to VIP queue.
# Customer 103 added to Regular queue.

# VIP Queue:
# Queue (front to rear): 201 -> 202 -> NULL
# Regular Queue:
# Queue (front to rear): 101 -> 102 -> 103 -> NULL

# Processing VIP Customer 201.
# Processing VIP Customer 202.
# Processing Regular Customer 101.
# Processing Regular Customer 102.
# Processing Regular Customer 103.
# No calls in the queue.

# VIP Queue:
# Queue (front to rear): NULL
# Regular Queue:
# Queue (front to rear): NULL