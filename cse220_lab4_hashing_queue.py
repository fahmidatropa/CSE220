# -*- coding: utf-8 -*-
"""cse220 lab4 hashing queue

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cy4ng7Xh7uzZOjkDDZgoHgOAjfGP4VOi
"""

#######hashing#########
# Node class to store key-value pairs in the linked list (collision handling)
class Node:
    def __init__(self, key, value):
        self.key = key
        self.value = value
        self.next = None

# HashTable class implementing Forward Chaining
class HashTable:
    def __init__(self, size):
        self.size = size
        self.table = [None] * size  # Array of linked lists

    # Hash function using modulus operation
    def hash_function(self, key):
        return abs(hash(key)) % self.size  # Ensure positive index

    # Insert method (updates value if key exists)
    def insert(self, key, value):
        index = self.hash_function(key)
        current = self.table[index]

        # Check if key exists and update value
        while current:
            if current.key == key:
                current.value = value  # Update value for existing key
                return
            current = current.next

        # Insert at the beginning (Forward Chaining)
        new_node = Node(key, value)
        new_node.next = self.table[index]
        self.table[index] = new_node

    # Search method
    def search(self, key):
        index = self.hash_function(key)
        current = self.table[index]

        while current:
            if current.key == key:
                return current.value
            current = current.next
        return None  # Key not found

    # Display method
    def display(self):
        for i in range(self.size):
            print(f"Index {i}:", end=" ")
            current = self.table[i]
            while current:
                print(f"({current.key}, {current.value}) ->", end=" ")
                current = current.next
            print("NULL")

# Main function for testing
if __name__ == "__main__":
    hash_table = HashTable(5)

    # Insert key-value pairs
    hash_table.insert(12, "Apple")
    hash_table.insert(5, "Orange")
    hash_table.insert(17, "Banana")
    hash_table.insert(10, "Grapes")
    hash_table.insert(22, "Watermelon")
    hash_table.insert(15, "Pineapple")

    # Insert a duplicate key with a different value (should update)
    hash_table.insert(10, "Updated Grapes")

    # Display the hash table
    hash_table.display()

    # Search for a key
    print("Search for key 17:", hash_table.search(17))
    print("Search for key 10:", hash_table.search(10))  # Should return "Updated Grapes"
    print("Search for key 8:", hash_table.search(8))    # Should return None

#######hashing#########
# Node class to store key-value pairs in the linked list (collision handling)
class Node:
    def __init__(self, key, value):
        self.key = key
        self.value = value
        self.next = None
# HashTable class implementing Forward Chaining
class HashTable:
    def __init__(self, size):
        self.size = size
        self.table = [None] * size  # Array of linked lists
    # Hash function using modulus operation
    def hash_function(self, key):
        return abs(hash(key)) % self.size  # Ensure positive index
    # Insert method (updates value if key exists)
    def insert(self, key, value):
     idx=self.hash_function(key)
     node=Node(key,value)
     if self.table[idx]==None:
       self.table[idx]=node
     else:
      temp=self.table[idx]
      while temp!=None:
        if temp.key==key:
          temp.value=value
          return
        temp=temp.next
      temp=self.table[idx]
      node.next=temp
      head=node
      self.table[idx]=head
    def search(self, key):
      idx=self.hash_function(key)
      if self.table[idx]==None:
        return 'None'
      else:
        temp=self.table[idx]
        while temp!=None:
            if temp.key==key:
              return temp.value
            temp=temp.next
        return 'None'
    def display(self):
        for i in range(self.size):
            print(f"Index {i}:", end=" ")
            current = self.table[i]
            while current:
                print(f"({current.key}, {current.value}) ->", end=" ")
                current = current.next
            print("NULL")

# Main function for testing
if __name__ == "__main__":
    hash_table = HashTable(5)

    # Insert key-value pairs
    hash_table.insert(12, "Apple")
    hash_table.insert(5, "Orange")
    hash_table.insert(17, "Banana")
    hash_table.insert(10, "Grapes")
    hash_table.insert(22, "Watermelon")
    hash_table.insert(15, "Pineapple")

    # Insert a duplicate key with a different value (should update)
    hash_table.insert(10, "Updated Grapes")

    # Display the hash table
    hash_table.display()

    # Search for a key
    print("Search for key 17:", hash_table.search(17))
    print("Search for key 10:", hash_table.search(10))  # Should return "Updated Grapes"
    print("Search for key 8:", hash_table.search(8))    # Should return None

key='morti'
key+='N'
print(key)

#task1
class Node_pair:
  def __init__(self, key, value, next = None):
    self.key, self.value, self.next = key, value, next
class Hashtable:
  def __init__(self, size):
    self.ht = [None]*size
  def insert(self, s):
    if self.search_hashtable(s) == 'Found':
      print(s,'Already Inserted. Cannot reinsert.')
      print('===============================')
      return
    hashed_index = self.__hash_function(s[0])
    pair = Node_pair(s[0], s[1])
    if self.ht[hashed_index] == None:
      self.ht[hashed_index] = pair
    else:
      pair.next = self.ht[hashed_index]
      self.ht[hashed_index] = pair
  def create_from_array(self, arr):
    for i in arr:
      self.insert(i)
  def print_hashtable(self):
    idx = 0
    for i in self.ht:
      print(idx, ':', end = ' ')
      head = i
      while head != None:
        print(f'(key: {head.key}, value: {head.value})', end = '-->')
        head = head.next
      print('None')
      print()
      idx +=1
  #Do it by yourself
  def __hash_function(self, key):
    #TO DO
    con=''
    idx=0
    if len(key)%2==0:
      for i in range(0,len(key),2):
        con=str(ord(key[i]))
        con+=str(ord(key[i+1]))
        idx+=int(con)
    else:
      key+='N'
      for i in range(0,len(key),2):
        con+=str(ord(key[i]))
        con+=str(ord(key[i+1]))
        idx+=int(con)
    return idx%len(self.ht)###########alws hashfunc e return hbe idx%len(hashtable)
  #Do it by yourself
  def search_hashtable(self, s):#s=tuple=('Doug', 1200)
    idx=self.__hash_function(s[0])#s[0]='Drug'
    key,value=s
    head=self.ht[idx]
    temp=head
    while temp!=None:
      if temp.key==key and temp.value==value:
        return 'Found'
      temp=temp.next
    return 'Not Found'
#Driver Code
arr = [('Colt', 360), ('Cordelius', 730), ('Shelly', 300), ('Doug', 1200), ('Emz', 520), ('Bo', 580)]
ht = Hashtable(5)
#print(ht.__hash_function('Mortis'))
ht.create_from_array(arr)
ht.print_hashtable()

print('======================')
result = ht.search_hashtable(('Doug', 1200))
print(f'(Doug, 1200) {result}')

print('======================')
ht.insert(('Doug', 1200))
ht.print_hashtable()

print('======================')
result = ht.search_hashtable(('Edgar', 320))
print(f'(Edgar, 320) {result}')

print('======================')
ht.insert(('Edgar', 320))
ht.print_hashtable()

print('======================')
result = ht.search_hashtable(('Edgar', 320))
print(f'(Edgar, 320) {result}')

#task2
class Node:
  def __init__(self, value=None, next = None): #key , value alada nei. ekhane self.value=(key,value)
    self.value = value# self.value=(key,value)
    self.next = next

class HashTable:
  def __init__(self, length):
    n = Node()
    self.ht = [n] * length
    self.length = length

  def show(self):
    count = 0
    for i in self.ht:
      temp = i
      print(count, end=" ")
      while temp!=None:
        print (temp.value, end="-->")
        temp = temp.next
      count += 1
      print()
  #Do it by yourself
  def __hash_function(self, key):
    #TO DO
    idx=0
    if len(key)%2==0:
     for i in range(len(key)):
      if i%2==0:
        idx+=ord(key[i])
    else:
     for i in range(0,len(key),2):
      if i%2!=0:
        idx+=ord(key[i])
    return idx%len(self.ht)
  #Do it by yourself
  def insert(self, key, value):#self,"apple", 20
    idx=self.__hash_function(key)#key='apple'
    head=self.ht[idx]
    temp=head
    node=Node((key,value)) #node.value=(key,value)
    #if node.value[1]
    if temp.value==None:
      self.ht[idx]=temp
    else:
     while temp!=None:
      if temp.value[1]<value:#temp.value=(key,value), value=20 for ht.insert("apple", 20)
       node.next=temp
       prev.next=node
     prev=temp
     temp=temp.next
#Driver Code
ht = HashTable(3)
ht.insert("apple", 20)
ht.insert("coconut", 90)
ht.insert("cherry", 50)
ht.show()
print("------------")
ht.insert("banana", 30)
ht.insert("pineapple", 50)
ht.show()
print("------------")
ht.insert("apple", 100)
ht.insert("guava", 10)
ht.show()
# Driver Code Output:
# 0 ('coconut', 90)-->
# 1 ('apple', 20)-->
# 2 ('cherry', 50)-->
# ------------
# 0 ('coconut', 90)-->('pineapple', 50)-->('banana', 30)-->
# 1 ('apple', 20)-->
# 2 ('cherry', 50)-->
# ------------
# 0 ('coconut', 90)-->('pineapple', 50)-->('banana', 30)-->
# 1 ('apple', 100)-->('guava', 10) -->
# 2 ('cherry', 50)-->

#task3
class Node_pair:
  def __init__(self, key, value, next = None):
    self.key, self.value, self.next = key, value, next
class Hashtable:
  def __init__(self, size):
    self.ht = [None]*size
  def insert(self, s):
    hashed_index = self.__hash_function(s[0])
    pair = Node_pair(s[0], s[1])
    if self.ht[hashed_index] == None:
      self.ht[hashed_index] = pair
    else:
      pair.next = self.ht[hashed_index]
      self.ht[hashed_index] = pair
  def create_from_array(self, arr):
    for i in arr:
      self.insert(i)
  def print_hashtable(self):
    idx = 0
    for i in self.ht:
      print(idx, ':', end = ' ')
      head = i
      while head != None:
        print(f'({head.key}, {head.value})', end = '-->')
        head = head.next
      print('None')
      idx += 1
  #Do it by yourself
  def __hash_function(self, key):
    return (key+3)%len(self.ht)
  #Do it by yourself
  def remove(self, key):
    #TO DO
    idx=self.__hash_function(key)
    head=self.ht[idx]
    temp=head
    if head.key==key:#when key matches the head node. exmplt remove(22).. here 22 is the head node key
      #self.ht[idx] = temp.next
      head=head.next
      #self.ht[idx]=head xxxxxxxxxxxxx cz its only modifies the local variable. doesnt make chng in the indext of hashtable
      self.ht[idx]=head#r9ght way to write is this
      return
    else:
      while temp!=None:
        if temp.key==key:
          prev.next=temp.next
        prev=temp
        temp=temp.next
#Driver Code
arr=[(34, 'Abid') , (4, 'Rafi'), (6, 'Karim'), (3, 'Chitra'), (22, 'Nilu')]
ht = Hashtable(6)
ht.create_from_array(arr)
ht.print_hashtable()

#This should print

#0: (3, “Chitra”) --> None
#1: (22, “Nilu”) --> (4, “Rafi”) --> (34, “Abid”) --> None
#2: None
#3: (6, “Karim”) --> None
#4: None
#5: None

print('======================')

ht.remove(9)
ht.print_hashtable()
#This should print

#0: (3, “Chitra”) --> None
#1: (22, “Nilu”) --> (4, “Rafi”) --> (34, “Abid”) --> None
#2: None
#3: (6, “Karim”) --> None
#4: None
#5: None

print('======================')
print('======================')

ht.remove(22)
ht.print_hashtable()
#This should print

#0: (3, “Chitra”) --> None
#1: (22, “Nilu”) --> (34, “Abid”) --> None
#2: None
#3: (6, “Karim”) --> None
#4: None
#5: None

#task2 gpt
class Node:
    def __init__(self, value=None, next=None):
        self.value = value
        self.next = next

class HashTable:
    def __init__(self, length):
        self.ht = [None] * length  # Corrected initialization
        self.length = length

    def show(self):
        for i in range(self.length):
            temp = self.ht[i]
            print(i, end=" ")
            while temp:
                print(temp.value, end=" --> ")
                temp = temp.next
            print()

    def __hash_function(self, key):
        idx = 0
        if len(key) % 2 == 0:
            for i in range(len(key)):
                if i % 2 == 0:
                    idx += ord(key[i])
        else:
            for i in range(len(key)):
                if i % 2 != 0:
                    idx += ord(key[i])
        return idx % self.length
    def insert(self, key, value):
        idx = self.__hash_function(key)
        node = Node((key, value))
        if self.ht[idx]==None:
            self.ht[idx] = node  # Insert directly if no node exists
            return
        head = self.ht[idx]
        temp = head
        prev = None
        while temp:
            if temp.value[0] == key:  # If key matches, update value
                temp.value = (key, value)
                return
            temp = temp.next
        # Reset temp and insert the new node in descending order
        temp = head
        if value > head.value[1]:  # Insert at the head if new value is greater
            node.next = head
            self.ht[idx] = node
            return

        while temp and temp.value[1] >= value:  # Find insertion point
            prev = temp
            temp = temp.next

        # Insert node in the correct position
        prev.next = node
        node.next = temp
#Driver Code
ht = HashTable(3)
ht.insert("apple", 20)
ht.insert("coconut", 90)
ht.insert("cherry", 50)
ht.show()
print("------------")
ht.insert("banana", 30)
ht.insert("pineapple", 50)
ht.show()
print("------------")
ht.insert("apple", 100)
ht.insert("guava", 10)
ht.show()

# Driver Code Output:
# 0 ('coconut', 90)-->
# 1 ('apple', 20)-->
# 2 ('cherry', 50)-->
# ------------
# 0 ('coconut', 90)-->('pineapple', 50)-->('banana', 30)-->
# 1 ('apple', 20)-->
# 2 ('cherry', 50)-->
# ------------
# 0 ('coconut', 90)-->('pineapple', 50)-->('banana', 30)-->
# 1 ('apple', 100)-->('guava', 10) -->
# 2 ('cherry', 50)-->

#task2
class Node:
  def __init__(self, value=None, next = None):
    self.value = value
    self.next = next
class HashTable:
  def __init__(self, length):
    n = Node()
    self.ht = [n] * length
    self.length = length
  def show(self):
    count = 0
    for i in self.ht:
      temp = i
      print(count, end=" ")
      while temp!=None:
        print (temp.value, end="-->")
        temp = temp.next
      count += 1
      print()
  #Do it by yourself
  def __hash_function(self, key):
    #TO DO
    idx=0
    if len(key)%2==0:
      for i in range (len(key)):
        if i%2==0:
          idx+=ord(key[i])
    else:
      for i in range (len(key)):
        if i%2!=0:
          idx+=ord(key[i])
    return idx%len(self.ht)
  #Do it by yourself
  def insert(self, key, value):
    #TO DO
    idx=self.__hash_function(key)
    node=Node((key,value))
    if self.ht[idx].value==None:#if there is node.value=None in this idx of hashtable
      self.ht[idx]=node
    else:#if there is node/LL in this idx
      head=self.ht[idx]
      temp=head
      prev=None
      if temp.value[1]<node.value[1]:#if the node insert in the head
        node.next=temp
        self.ht[idx]=node
        return
      while temp!=None:#if the node insert in the tail
        if temp.value[1]>node.value[1] and temp.next==None:
          temp.next=node
          return
      else:#if the node insert in somewhere in the middle
       while temp!=None:
        if temp.value[1]<node.value[1]:
          prev.next=node
          node.next=temp
          return
        prev=temp
        temp=temp.next
       prev.next=node
#Driver Code
ht = HashTable(3)
ht.insert("apple", 20)
ht.insert("coconut", 90)
ht.insert("cherry", 50)
ht.show()
print("------------")
ht.insert("banana", 30)
ht.insert("pineapple", 50)
ht.show()
print("------------")
ht.insert("apple", 100)
ht.insert("guava", 10)
ht.show()

# Driver Code Output:
# 0 ('coconut', 90)-->
# 1 ('apple', 20)-->
# 2 ('cherry', 50)-->
# ------------
# 0 ('coconut', 90)-->('pineapple', 50)-->('banana', 30)-->
# 1 ('apple', 20)-->
# 2 ('cherry', 50)-->
# ------------
# 0 ('coconut', 90)-->('pineapple', 50)-->('banana', 30)-->
# 1 ('apple', 100)-->('guava', 10) -->
# 2 ('cherry', 50)-->

#task2 #st
class Node:
    def __init__(self, value=None, next=None):
        self.value = value
        self.next = next
class HashTable:
    def __ini__t(self, length):
        self.ht = [None] * length  # Initialize with None
        self.length = length
    def show(self):
        count = 0
        for i in self.ht:
            temp = i
            print(count, end=" ")
            while temp != None:
                print(temp.value, end=" --> ")
                temp = temp.next
            count += 1
            print()
    def hash_function(self, key):
        idx = 0
        if len(key) % 2 == 0:
            for i in range(len(key)):
                if i % 2 == 0:
                    idx += ord(key[i])
        else:
            for i in range(len(key)):
                if i % 2 != 0:
                    idx += ord(key[i])
        return idx % len(self.ht)
    def insert(self, key, value):
        idx = self.hash_function(key)
        node = Node((key, value))
        if self.ht[idx] is None:
            self.ht[idx] = node
        else:
            head = self.ht[idx]
            temp = head
            prev = None
            if temp.value[1] < node.value[1]:
                node.next = head
                self.ht[idx] = node
                return
            while temp is not None:
                if temp.value[1] > node.value[1]:
                    if temp.next is None or temp.next.value[1] < node.value[1]:
                        if prev:
                            prev.next = node
                        node.next = temp
                        return
                prev = temp
                temp = temp.next
            prev.next = node
#Driver Code
ht = HashTable(3)
ht.insert("apple", 20)
ht.insert("coconut", 90)
ht.insert("cherry", 50)
ht.show()
print("------------")
ht.insert("banana", 30)
ht.insert("pineapple", 50)
ht.show()
print("------------")
ht.insert("apple", 100)
ht.insert("guava", 10)
ht.show()

# Driver Code Output:
# 0 ('coconut', 90)-->
# 1 ('apple', 20)-->
# 2 ('cherry', 50)-->
# ------------
# 0 ('coconut', 90)-->('pineapple', 50)-->('banana', 30)-->
# 1 ('apple', 20)-->
# 2 ('cherry', 50)-->
# ------------
# 0 ('coconut', 90)-->('pineapple', 50)-->('banana', 30)-->
# 1 ('apple', 100)-->('guava', 10) -->
# 2 ('cherry', 50)-->

#task2 submit
class Node:
    def __init__(self, value=None, next=None):
        self.value = value
        self.next = next
class HashTable:
    def __init__(self, length):
        self.ht = [None] * length
        self.length = length
    def show(self):
        count = 0
        for i in self.ht:
            temp = i
            print(count, end=" ")
            while temp is not None:
                print(temp.value, end=" --> ")
                temp = temp.next
            count += 1
            print()
    def hash_function(self, key):
        idx = 0
        if len(key) % 2 == 0:
            for i in range(len(key)):
                if i % 2 == 0:
                    idx += ord(key[i])
        else:
            for i in range(len(key)):
                if i % 2 != 0:
                    idx += ord(key[i])
        return idx % len(self.ht)
    def insert(self, key, value):
        idx = self.hash_function(key)
        node = Node((key, value))
        if self.ht[idx] is None:
            self.ht[idx] = node
            return
        head = self.ht[idx]
        temp = head
        prev = None
        while temp!=None:
            if temp.value[0]==key:
                temp.value = (key, value)
                return
            prev = temp
            temp = temp.next
        temp = head
        prev = None
        while temp!=None and temp.value[1]>=node.value[1]:
            prev = temp
            temp = temp.next
        if prev==None:
            node.next = self.ht[idx]
            self.ht[idx] = node
        else:
            prev.next = node
            node.next = temp
#Driver Code
ht = HashTable(3)
ht.insert("apple", 20)
ht.insert("coconut", 90)
ht.insert("cherry", 50)
ht.show()
print("------------")
ht.insert("banana", 30)
ht.insert("pineapple", 50)
ht.show()
print("------------")
ht.insert("apple", 100)
ht.insert("guava", 10)
ht.show()
# Driver Code Output:
# 0 ('coconut', 90)-->
# 1 ('apple', 20)-->
# 2 ('cherry', 50)-->
# ------------
# 0 ('coconut', 90)-->('pineapple', 50)-->('banana', 30)-->
# 1 ('apple', 20)-->
# 2 ('cherry', 50)-->
# ------------
# 0 ('coconut', 90)-->('pineapple', 50)-->('banana', 30)-->
# 1 ('apple', 100)-->('guava', 10) -->
# 2 ('cherry', 50)-->

class Node:
    def __init__(self, elem):
        self.elem = elem
        self.next = None
class LinkedListQueue:
    def __init__(self):
        self.front = self.rear = None  # Initially, no elements
    def enqueue(self, elem):
        new_node = Node(elem)
        if self.rear is None:  # Empty queue case
            self.front = self.rear = new_node
            return
        self.rear.next = new_node
        self.rear = new_node
    def dequeue(self):
        if self.is_empty():
            return None  # Return None instead of raising an error
        removed_elem = self.front.elem
        self.front = self.front.next
        if self.front==None:  # If queue becomes empty, reset rear
            self.rear=None
        return removed_elem
    def is_empty(self):
        return self.front is None
    def display_queue(self):
        print("Queue (front to rear):", end=" ")
        current = self.front
        while current:
            print(f"{current.elem} ->", end=" ")
            current = current.next
        print("NULL")
class CallQueue:
    def __init__(self):
        self.vip_queue = LinkedListQueue()
        self.regular_queue = LinkedListQueue()
    def enqueue_call(self, customer_id, is_vip):
        if is_vip:
            print(f"Customer {customer_id} added to VIP queue.")
            self.vip_queue.enqueue(customer_id)
        else:
            print(f"Customer {customer_id} added to Regular queue.")
            self.regular_queue.enqueue(customer_id)
    def dequeue_call(self):
        if self.vip_queue.is_empty()==False:  # Process VIP first
            customer_id = self.vip_queue.dequeue()
            print(f"Processing VIP Customer {customer_id}.")
        elif not self.regular_queue.is_empty():  # Process regular if VIP is empty
            customer_id = self.regular_queue.dequeue()
            print(f"Processing Regular Customer {customer_id}.")
        else:
            print("No calls in the queue.")  # No customers left
    def display_queue(self):
        print("\nVIP Queue:")
        self.vip_queue.display_queue()
        print("Regular Queue:")
        self.regular_queue.display_queue()
# Testing the corrected code
call_center = CallQueue()
# Enqueueing customers
call_center.enqueue_call(101, False)  # Regular customer
call_center.enqueue_call(201, True)   # VIP customer
call_center.enqueue_call(102, False)  # Regular customer
call_center.enqueue_call(202, True)   # VIP customer
call_center.enqueue_call(103, False)  # Regular customer
call_center.display_queue()
# Processing calls
call_center.dequeue_call()
call_center.dequeue_call()
call_center.dequeue_call()
call_center.dequeue_call()
call_center.dequeue_call()
call_center.dequeue_call()  # No more calls

call_center.display_queue()