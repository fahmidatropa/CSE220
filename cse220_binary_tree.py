# -*- coding: utf-8 -*-
"""CSE220 Binary Tree

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1noEOaMCBVyI86xgJX9EjLYA9Sf51tUVZ
"""

class TreeNode:
    def __init__(self, elem):
        self.elem = elem
        self.left = None
        self.right = None
class BinaryTree:
    def __init__(self):
        self.root = None
    # 1. Create a binary tree from array (ignoring index 0)
    def create_tree_from_array(self, arr, i):
        if i >= len(arr) or arr[i] == None:
            return None
        node = TreeNode(arr[i])
        node.left = self.create_tree_from_array(arr, 2 * i)
        node.right = self.create_tree_from_array(arr, 2 * i + 1)
        return node
    # 2. Depth of a node
    def depth(self, node, key, d):
        if node is None:
            return -1
        if node.elem == key:
            return d
        left = self.depth(node.left, key, d + 1)
        if left != -1:
            return left
        return self.depth(node.right, key, d + 1)
  #        1
  #      /   \
  #    2       3
  #   / \     / \
  #  4   5   6   7
    # 3. Height of a node
    def height(self, node):#starting e node=root... pore chng hoise aste aste cz deep e gese tree er...jar path boro/level besi/edges besi setai height of that tree
        if node==None:
            return -1#leaf node asle. er kono height thakbena. so -1 krle +1 jeta krsi oita kete jabe(1-1=0).. last return statement e
        left = self.height(node.left)#findig height of left subtree
        right = self.height(node.right)##findig height of right subtree
        return 1+ max(left, right)#when its node=4... 1+max(-1, -1)=1+(-1) .. max er vitore jeta boro seta nibo. ekhane duitai -1 ti -1 nisi
        #1 + krsi cz. root er edge to thakbei. bt root.left/right subtree na thakle -1 return hbe. tkhn ei +1 kete jabe.


        #alternative way/short cut
        # if node is None:
        #     return -1
        # return 1+ max(self.height(node.left),self.height(node.right))
    # 4. Number of nodes
    def count_nodes(self, node):
        if node==None:
            return 0
        left=self.count_nodes(node.left)
        right=self.count_nodes(node.right)
        return 1+left+right
    # alternative way
    # def count_nodes(self, node):
    #     if node is None:
    #         return 0
    #     return 1 + self.count_nodes(node.left) + self.count_nodes(node.right)
  #     1
  #    / \
  #   2   3
  #  / \
  # 4   5
    # 5. Full binary tree check
    def is_full(self, node):
        if node is None:
            return True
        if (node.left is None and node.right is not None) or (node.left is not None and node.right is None):
            return False
        return self.is_full(node.left) and self.is_full(node.right)
    # 6. Complete binary tree check
    def is_complete(self, node, index, total_nodes):
        if node is None:
            return True
        if index > total_nodes:
            return False
        return (self.is_complete(node.left, 2 * index, total_nodes) and
                self.is_complete(node.right, 2 * index + 1, total_nodes))
    # 7. Perfect binary tree check
    def is_perfect(self, node, depth, level):
        if node is None:
            return True
        if node.left is None and node.right is None:
            return depth == level
        if node.left is None or node.right is None:
            return False
        return (self.is_perfect(node.left, depth, level + 1) and
                self.is_perfect(node.right, depth, level + 1))
    # 8. Balanced binary tree check
    def is_balanced(self, node):
        return self.check_balance(node) != -1
    def check_balance(self, node):
        if node is None:
            return 0
        left = self.check_balance(node.left)
        right = self.check_balance(node.right)
        if left == -1 or right == -1 or abs(left - right) > 1:
            return -1
        return max(left, right) + 1
# Testing the BinaryTree class
if __name__ == "__main__":
    bt = BinaryTree()
    arr = [0, 1, 2, 3, 4, 5, 6, 7]  # index 0 is ignored
    bt.root = bt.create_tree_from_array(arr, 1)

    print("Depth of 6:", bt.depth(bt.root, 6, 0))
    print("Height of root:", bt.height(bt.root))
    print("Number of nodes:", bt.count_nodes(bt.root))
    print("Is Full:", bt.is_full(bt.root))
    total_nodes = bt.count_nodes(bt.root)
    print("Is Complete:", bt.is_complete(bt.root, 1, total_nodes))
    print("Is Perfect:", bt.is_perfect(bt.root, bt.height(bt.root), 0))
    print("Is Balanced:", bt.is_balanced(bt.root))

#     10
#    /  \
#   16  25
#   /  / \
#   5  8  3
#pre-order = 10 16 5 25 8 3
Node10 = TreeNode(10)
Node16 = TreeNode(16)
Node25 = TreeNode(25)
Node10.left = Node16
Node10.right = Node25
Node5 = TreeNode(5)
Node8 = TreeNode(8)
Node3 = TreeNode(3)
Node16.left = Node5
Node25.left = Node8
Node25.right = Node3

root = Node10
print(root.right.left.elem)

def preOrder(root): #root,left,right
    # Base Case
    if root == None:
        return
    # recursive part
    print(root.elem, end = " ")
    preOrder(root.left)
    preOrder(root.right)

preOrder(root)

#pre-order = 10 16 5 25 8 3
arr = [None, 10, 7, 15, None, 18, 13, 17, None, None, 19, 25, None, 20, 27, None]
BT = BinaryTree()
root = BT.create_tree_from_array(arr, 1)

preOrder(root)

def inOrder(root): #left,root,right
    # Base Case
    if root == None:
        return
    # recursive part
    inOrder(root.left)
    print(root.elem, end = " ")
    inOrder(root.right)
inOrder(root)
#     10
#    /  \
#   16  25
#   /  / \
#   5  8  3

def postOrder(root): #left,right,root
    # Base Case
    if root == None:
        return
    # recursive part
    postOrder(root.left)
    postOrder(root.right)
    print(root.elem, end = " ")
postOrder(root)

def TreeSum(root, lvl):
    if root == None:
        return 0
    if lvl == 0:
        return root.elem + TreeSum(root.left, lvl+1) + TreeSum(root.right, lvl+1)
    else:
        return root.elem%lvl + TreeSum(root.left, lvl+1) + TreeSum(root.right, lvl+1)
TreeSum(root, 0)

def NodeCount(root):
    if root == None:
        return 0
    return 1 + NodeCount(root.left) + NodeCount(root.right)
NodeCount(root)

def height(root):
   if root == None:
        return -1
   left = height(root.left)
   right = height(root.right)
   return max(left, right) + 1
height(root)

A
       / \
      B   C
     / \
    D   E