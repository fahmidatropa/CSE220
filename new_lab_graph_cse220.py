# -*- coding: utf-8 -*-
"""new lab graph cse220

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VwXr8VlSyavRGt9h9-CszKgLHzBHOoRF
"""

#tas0a matrix
import numpy as np
graph = np.zeros((6, 6), dtype=int)
graph[0][5] = 15
graph[1][2], graph[1][5] = 44, 8#1,2 er sthe connection creat krlam jar wieght 44, and 1 er stge 5 er connection create krlam jar weight 8
graph[2][1], graph[2][3], graph[2][4] = 44, 9, 10
graph[3][2], graph[3][4], graph[3][5] = 9, 7, 15
graph[4][2], graph[4][3] = 10, 7
graph[5][0], graph[5][1], graph[5][3] = 15, 8, 15
print(graph)

#task0b .............
class Edge:
    def __init__(self, destination, next_node=None):
        self.destination = destination
        self.next = next_node
class AdjacencyListGraph:
    def __init__(self, num_vertices):
        self.num_vertices = num_vertices
        self.adj_list = [None] * num_vertices
    def add_edges(self, edges):
        for source, destination in edges:
            self.add_edge(source, destination)
            self.add_edge(destination, source)  # For undirected graph
    def add_edge(self, source, destination):
        new_edge = Edge(destination)
        if self.adj_list[source]==None:
            self.adj_list[source]=new_edge
        else:
            temp=self.adj_list[source]
            new_edge.next=temp
            self.adj_list[source]=new_edge
    def print_graph(graph):
     for i in range(len(graph)):
        print(f"Node {i}:", end=" ")
        temp = graph[i]
        while temp!=None:
            e = temp.edge
            print(f"-->({e.v}, {e.w})", end="")
            temp = temp.next
        print()
# Print the graph
# Driver code
num_vertices = 7
edges = [
    (0, 1), (0, 2), (0, 3), (1, 2), (1, 4), (1, 5),
    (2, 3), (2, 6), (3, 4), (3, 6), (4, 5), (4, 6),
    (5, 6), (5, 0), (6, 1), (6, 0)
]
graph = AdjacencyListGraph(num_vertices)
graph.add_edges(edges)
print_graph(graph2)

#task1b
class Edge:
    def __init__(self, destination, next_node=None):
        self.destination = destination
        self.next = next_node
class AdjacencyListGraph:
    def __init__(self, num_vertices):
        self.num_vertices = num_vertices
        self.adj_list = [None] * num_vertices
    def add_edges(self, edges):
        for source, destination in edges:
            self.add_edge(source, destination)
            self.add_edge(destination, source)  # For undirected graph
    def add_edge(self, source, destination):
        new_edge = Edge(destination)
        if self.adj_list[source]==None:
            self.adj_list[source]=new_edge
        else:
            temp=self.adj_list[source]
            new_edge.next=temp
            self.adj_list[source]=new_edge
        return
    def max_degree(self):
        maxdegree = 0
        for i in self.adj_list:
            degree = 0
            temp = i
            while temp:
                degree += 1
                temp = temp.next
            if degree > maxdegree:
                maxdegree = degree
        return maxdegree
# Driver code
num_vertices = 7
edges = [
    (0, 1), (0, 2), (0, 3), (1, 2), (1, 4), (1, 5),
    (2, 3), (2, 6), (3, 4), (3, 6), (4, 5), (4, 6),
    (5, 6), (5, 0), (6, 1), (6, 0)
]
graph = AdjacencyListGraph(num_vertices)
graph.add_edges(edges)
print(graph.max_degree())

#task1a
import numpy as np
class Graph:
  def __init__(self,vertices):
    self.vertices=vertices
    self.matrix=np.zeros((vertices,vertices),dtype=int)
  def addedges(self,edges):
    for u,v in edges:
      self.matrix[u][v]=1
      self.matrix[v][u]=1
  def printmatrix(self):
    print(self.matrix)
  def maxdegree(self):
    maxdeg=0
    row,col=len(self.matrix),len(self.matrix[0])
    for r in range(row):
      count=0
      for c in range(col):
        if self.matrix[r][c]==1:
           count+=1
      if count>maxdeg:
        maxdeg=count
    return maxdeg
#driver code
vertices=7
edges=[(0, 1), (0, 2), (0, 3), (1, 2), (1, 4), (1, 5),
    (2, 3), (2, 6), (3, 4), (3, 6), (4, 5), (4, 6),
    (5, 6), (5, 0), (6, 1), (6, 0)]
graph=Graph(vertices)
graph.addedges(edges)
graph.printmatrix()
graph.maxdegree()

#task2a
import numpy as np
class Graph:
    def __init__(self, numver):
        self.numver=numver
        self.adjmatrix = np.zeros((numver,numver), dtype=int)#(row,col)
    def add_edges(self,edges):
      for u,v,w in edges:
        self.adjmatrix[u][v]=w
        self.adjmatrix[v][u]=w
    def maxver(self):
       maxw=0
       maxver=0
       row,col=len(self.adjmatrix),len(self.adjmatrix[0])
       for r in range(row):
         weight=0
         for c in range(col):
           if self.adjmatrix[r][c]!=0:
             weight+=self.adjmatrix[r][c]
         if maxw<weight:
            maxw=weight
            maxver=r
       return maxver
num_vertices = 7
edges = [(0, 1, 4), (0, 2, 3), (0, 3, 2), (1, 2, 5), (1, 4, 7), (1, 5, 6),
    (2, 3, 4), (2, 6, 8), (3, 4, 2), (3, 6, 5), (4, 5, 1), (4, 6, 6),
    (5, 6, 3), (5, 0, 2), (6, 1, 4), (6, 0, 7)]
graph = Graph(num_vertices)
graph.add_edges(edges)
print(graph.maxver())

#task2b
class Node:
  def __init__ (self,u,v,w,next=None):
    self.u=u
    self.v=v
    self.w=w
    self.next=next
class Graph:
    def __init__ (self,numver):
      self.numver=numver
      self.adjlist=[None]*numver
    def add_edges(self,edges):
      for u,v,w in edges:
        self.add_edge(u,v,w)
        self.add_edge(v,u,w)
    def add_edge(self,u,v,w):
      new_node=Node(u,v,w)
      if self.adjlist[u]==None:
        self.adjlist[u]=new_node
      else:
        temp=self.adjlist[u]
        new_node.next=temp
        self.adjlist[u]=new_node
    def maxver(self):
          max_w=-1
          vertex = -1
          for i in range(len(self.adjlist)):
              count=0
              temp = self.adjlist[i]
              while temp != None:
                  count += temp.w
                  temp = temp.next
              if count > max_w:
                  max_w = count
                  vertex = i
          return vertex
num_vertices = 7
edges = [(0, 1, 4), (0, 2, 3), (0, 3, 2), (1, 2, 5), (1, 4, 7), (1, 5, 6),
    (2, 3, 4), (2, 6, 8), (3, 4, 2), (3, 6, 5), (4, 5, 1), (4, 6, 6),
    (5, 6, 3), (5, 0, 2), (6, 1, 4), (6, 0, 7)]
graph = Graph(num_vertices)
graph.add_edges(edges)
print(graph.maxver())

#task3a
import numpy as np
class dGraph:
    def __init__(self, numver):
        self.numver=numver
        self.matrix = np.zeros((numver,numver), dtype=int)#(row,col)
    def add_edges(self,edges):
        for u,v,w in edges:
            self.matrix[u][v]=w
    #finding vertex with max out-degree
    def maxdeg(self):
        maxdegree=0
        row,col=len(self.matrix),len(self.matrix[0])
        for r in range(row):
            degree=0
            for c in range(col):
                if self.matrix[r][c]!=0:
                    degree+=1
            if degree>maxdegree:
                maxdegree=degree
        return maxdegree  # return vertexgii
    #finding the vertex with max weight
    def maxver(self):
        maxw=0
        maxver=0
        row,col=len(self.matrix),len(self.matrix[0])
        for r in range(row):
            weight=0
            for c in range(col):
                if self.matrix[r][c]!=0:
                    weight+=self.matrix[r][c]
            if maxw<weight:
                maxw=weight
                maxver=r
        return maxver   # return vertex
num_vertices = 7
edges = [(0, 1, 4), (0, 2, 3), (0, 3, 2), (1, 2, 5), (1, 4, 7), (1, 5, 6),
    (2, 3, 4), (2, 6, 8), (3, 4, 2), (3, 6, 5), (4, 5, 1), (4, 6, 6),
    (5, 6, 3), (5, 0, 2), (6, 1, 4), (6, 0, 7)]

graph = dGraph(num_vertices)
graph.add_edges(edges)
print(graph.maxdeg())#3
print(graph.maxver())#1

#task3b
class Node:
  def __init__ (self,u,v,w,next=None):
    self.u=u
    self.v=v
    self.w=w
    self.next=next
class Graph:
    def __init__ (self,numver):
      self.numver=numver
      self.adjlist=[None]*numver
    def add_edges(self,edges):
      for u,v,w in edges:
        self.add_edge(u,v,w)
    def add_edge(self,u,v,w):
      new_node=Node(u,v,w)
      if self.adjlist[u]==None:
        self.adjlist[u]=new_node
      else:
        temp=self.adjlist[u]
        new_node.next=temp
        self.adjlist[u]=new_node
    def maxdeg(self):
        maxdegree=0
        for i in self.adjlist:
            degree=0
            temp = i
            while temp:
                degree += 1
                temp = temp.next
            if degree > maxdegree:
                maxdegree = degree
        return maxdegree
    def maxver(self):
          max_w=-1
          vertex = -1
          for i in range(len(self.adjlist)):
              count=0
              temp = self.adjlist[i]
              while temp != None:
                  count += temp.w
                  temp = temp.next
              if count > max_w:
                  max_w = count
                  vertex = i
          return vertex
num_vertices = 7
edges = [(0, 1, 4), (0, 2, 3), (0, 3, 2), (1, 2, 5), (1, 4, 7), (1, 5, 6),
    (2, 3, 4), (2, 6, 8), (3, 4, 2), (3, 6, 5), (4, 5, 1), (4, 6, 6),
    (5, 6, 3), (5, 0, 2), (6, 1, 4), (6, 0, 7)]
graph = Graph(num_vertices)
graph.add_edges(edges)
print(graph.maxdeg())#3
print(graph.maxver())

#task4a ***(adjacency matrix representation)
import numpy as np
class directed_Weighted_AdjacencyMatrix:
    def __init__(self, num_vertices):
        self.num_vertices=num_vertices
        self.adj_matrix=np.zeros((num_vertices, num_vertices), dtype=int)
    def add_edges(self,edges):
        for u, v, weight in edges:
            self.adj_matrix[u][v]=weight
    def convert_undirect_matrix(self):
        for i in range(self.num_vertices):
          for j in range(self.num_vertices):
            if self.adj_matrix[i][j]!=0:
              self.adj_matrix[j][i]=self.adj_matrix[i][j]
        return self.adj_matrix
# Driver code
num_vertices = 7
edges = [    (1, 5, 6),
    (0, 3, 2),
    (4, 6, 6),
    (2, 6, 8),
    (0, 2, 3),
    (3, 6, 5),
    (5, 0, 2),
    (6, 0, 7),
    (1, 4, 7),
    (2, 3, 4),
    (3, 4, 2),
    (5, 6, 3),
    (0, 1, 4),
    (1, 2, 5),
    (6, 1, 4),
    (4, 5, 1)

]
graph = directed_Weighted_AdjacencyMatrix(num_vertices)
graph.add_edges(edges)
print(graph.convert_undirect_matrix())

#task4b **(adjacency list representation)
class Node:
    def __init__(self,u,v,w,next_node=None):
      self.u=u
      self.v=v
      self.w=w
      self.next_node=next_node
class Graph:
  def __init__(self,num_vertices):
    self.num_vertices=num_vertices
    self.adj_list=[None]*self.num_vertices
  def add_edges(self,edges):
    for u,v,w in edges:
      self.add_edge(u,v,w)
  def add_edge(self,u,v,w):
    newnode=Node(u,v,w)
    newnode.next=self.adj_list[u]
    self.adj_list[u]=newnode
  def edge_exists(self, u, v):
    temp=self.adj_list[u]
    while temp!=None:
      if temp.v==v:
        return False
      temp=temp.next
    return True
  def convert_undrect(self):
    for i in self.adj_list:
      temp=i
      while temp!=None:
        v1=temp.u
        u1=temp.v
        if self.edge_exists(u1,v1):
          self.add_edge(u1,v1,temp.w)
        temp=temp.next
  def print_list(self):
        print( "indirect Adjacency List with Weights:")
        for i in self.adj_list:
          temp=i
          print(temp.u,end=':')
          while temp!=None:
            if temp.next==None:
              print(f"({temp.v},{temp.w})")
            else:
              print(f"({temp.v},{temp.w})",end=",")
            temp=temp.next
# Driver code
num_vertices=7
edges=[(0, 1, 4), (0, 2, 3), (0, 3, 2), (1, 2, 5), (1, 4, 7), (1, 5, 6),
    (2, 3, 4), (2, 6, 8), (3, 4, 2), (3, 6, 5), (4, 5, 1), (4, 6, 6),
    (5, 6, 3), (5, 0, 2), (6, 1, 4), (6, 0, 7)]
graph=Graph(num_vertices)
graph.add_edges(edges)
graph.convert_undrect()
graph.print_list()

#task4b **(adjacency list representation)
class Node:
    def __init__(self,u,v,w,next_node=None):
      self.u=u
      self.v=v
      self.w=w
      self.next_node=next_node
class Graph:
  def __init__(self,num_vertices):
    self.num_vertices=num_vertices
    self.adj_list=[None]*self.num_vertices
  def add_edges(self,edges):
    for u,v,w in edges:
      self.add_edge(u,v,w)
  def add_edge(self,u,v,w):
    newnode=Node(u,v,w)
    newnode.next=self.adj_list[u]
    self.adj_list[u]=newnode
  def edge_exists(self, u, v):
    temp=self.adj_list[u]
    while temp!=None:
      if temp.v==v:
        return False
      temp=temp.next
    return True
  def convert_undrect(self):
   for i in self.adj_list:
    temp=i
    while temp!=None:
      if self.edge_exists(temp.v,temp.u):
        self add_edge(temp.v,temp.u,temp.w)

# Driver code
num_vertices=7
edges=[(0, 1, 4), (0, 2, 3), (0, 3, 2), (1, 2, 5), (1, 4, 7), (1, 5, 6),
    (2, 3, 4), (2, 6, 8), (3, 4, 2), (3, 6, 5), (4, 5, 1), (4, 6, 6),
    (5, 6, 3), (5, 0, 2), (6, 1, 4), (6, 0, 7)]
graph=Graph(num_vertices)
graph.add_edges(edges)
graph.convert_undrect()
graph.print_list()